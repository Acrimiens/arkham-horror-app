Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\extraer_contexto.ps1
--------------------------------------------------
# Define la carpeta raÃ­z de tu proyecto
$proyectoRaiz = "C:\Users\GGTECH\Documents\PERSONAL\ARKHAM"

# Nombre del archivo de salida (se recomienda ubicarlo fuera del contenido exportado o controlarlo)
$archivoSalida = "contenido_proyecto.txt"

# FunciÃ³n para procesar archivos en una carpeta de forma recursiva
function ProcesarCarpeta {
    param(
        [string]$carpeta
    )

    # Obtiene todos los archivos DIRECTAMENTE en la carpeta
    $archivos = Get-ChildItem -Path $carpeta -File

    foreach ($archivo in $archivos) {
        # Omitir el archivo de salida para evitar incluirlo en la exportaciÃ³n
        if ($archivo.Name -eq $archivoSalida) { continue }
        
        # Ignorar archivos con las extensiones especificadas
        if ($archivo.Extension -in ".woff", ".woff2", ".jpg", ".png", ".webp") { continue }

        # Agrega la ruta del archivo al archivo de salida
        "Archivo: $($archivo.FullName)" | Out-File -FilePath $archivoSalida -Append -Encoding UTF8
        "--------------------------------------------------" | Out-File -FilePath $archivoSalida -Append -Encoding UTF8

        # Intenta leer y escribir el contenido del archivo
        try {
            Get-Content $archivo.FullName -ErrorAction SilentlyContinue | Out-File -FilePath $archivoSalida -Append -Encoding UTF8
        } catch {
            Write-Warning "Error al leer el archivo: $($archivo.FullName) - $($_.Exception.Message)"
            "Error al leer el archivo: $($archivo.FullName) - $($_.Exception.Message)" | Out-File -FilePath $archivoSalida -Append -Encoding UTF8
        }

        # Agrega lÃ­neas en blanco para separar archivos
        "" | Out-File -FilePath $archivoSalida -Append -Encoding UTF8
        "" | Out-File -FilePath $archivoSalida -Append -Encoding UTF8
    }

    # Obtiene todas las subcarpetas DIRECTAMENTE en la carpeta
    $subcarpetas = Get-ChildItem -Path $carpeta -Directory

    foreach ($subcarpeta in $subcarpetas) {
        # Llama recursivamente a la funciÃ³n para procesar la subcarpeta
        ProcesarCarpeta -carpeta $subcarpeta.FullName
    }
}

# Inicia el procesamiento desde la carpeta raÃ­z del proyecto
ProcesarCarpeta -carpeta $proyectoRaiz


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\gitignore-file.txt
--------------------------------------------------
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# celery beat schedule file
celerybeat-schedule

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# VS Code
.vscode/
*.code-workspace

# PyCharm
.idea/

# Archivos especÃ­ficos del SO
.DS_Store
Thumbs.db


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\quickstart-guide.txt
--------------------------------------------------
# GuÃ­a de Inicio RÃ¡pido

Esta guÃ­a te ayudarÃ¡ a verificar que la aplicaciÃ³n funcione correctamente despuÃ©s de la reorganizaciÃ³n.

## 1. ConfiguraciÃ³n del entorno

1. Clona el repositorio (o copia los archivos a tu directorio de trabajo)
2. Crea y activa un entorno virtual:
   ```bash
   python -m venv venv
   # En Windows:
   venv\Scripts\activate
   # En Linux/Mac:
   source venv/bin/activate
   ```
3. Instala las dependencias:
   ```bash
   pip install -r requirements.txt
   ```

## 2. Ejecuta la aplicaciÃ³n en modo desarrollo

```bash
python run.py
```

La aplicaciÃ³n deberÃ­a iniciarse en modo de desarrollo y estar disponible en: http://localhost:5000

## 3. Verificar la funcionalidad de login

1. **Login como mesa**:
   - Utiliza uno de los cÃ³digos de mesa predefinidos, por ejemplo: `mesa01`
   - DeberÃ­as ser redirigido a la era correspondiente (pasado, presente, futuro)

2. **Login como administrador**:
   - Usa las credenciales: `admin1` / `clave1`
   - DeberÃ­as ser redirigido al panel de administraciÃ³n

## 4. Verificar la funcionalidad del panel de administraciÃ³n

1. **AÃ±adir un nuevo grupo**:
   - Haz clic en el botÃ³n "+ Crear"
   - DeberÃ­a crearse un nuevo grupo con sus cÃ³digos de mesa correspondientes

2. **Generar cÃ³digos QR**:
   - Haz clic en "Ver e Imprimir Todos los QR"
   - DeberÃ­as ver todos los cÃ³digos QR generados correctamente

3. **Acceder a un grupo especÃ­fico**:
   - Haz clic en "Acceder" para cualquier grupo
   - DeberÃ­as poder ver y seleccionar las diferentes eras

## 5. Verificar la funcionalidad de las eras

1. **Activar/desactivar anuncios**:
   - Intenta activar varios anuncios
   - Verifica que las dependencias se respeten (algunos anuncios requieren que otros estÃ©n activos)

2. **Contador de Biff Tannen**:
   - Incrementa el contador de derrotas
   - Verifica que se actualice correctamente

3. **Contadores de recursos**:
   - Agrega y envÃ­a recursos en los diferentes contadores
   - Verifica que se reflejen en los totales

## Problemas comunes y soluciones

- **Errores de importaciÃ³n**: Verifica que las carpetas contengan archivos `__init__.py` correctos.
- **Errores de ruta**: AsegÃºrate de que las rutas en los controladores coincidan con las referencias en los templates.
- **Errores de Socket.IO**: Verifica que la configuraciÃ³n de Socket.IO sea correcta tanto en el servidor como en el cliente.

## Despliegue en Render

1. Sube el cÃ³digo a un repositorio Git
2. Crea un nuevo servicio web en Render vinculado a tu repositorio
3. Usa la configuraciÃ³n de `render.yaml` o configura manualmente:
   - Build Command: `pip install -r requirements.txt`
   - Start Command: `gunicorn -k geventwebsocket.gunicorn.workers.GeventWebSocketWorker -w 1 wsgi:app`
   - Variables de entorno:
     - `RENDER`: `true`
     - `FLASK_ENV`: `production`


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\readme.md.txt
--------------------------------------------------
# Arkham Horror - AplicaciÃ³n para el 2Âº Aniversario de Ignota Alicante

AplicaciÃ³n web para gestionar el juego de mesa Arkham Horror durante el evento del 2Âº aniversario de Ignota Alicante.

## Estructura del proyecto (MVC)

El proyecto sigue una estructura similar al patrÃ³n Modelo-Vista-Controlador:

```
/
â”œâ”€â”€ app/                            # Carpeta principal de la aplicaciÃ³n
â”‚   â”œâ”€â”€ __init__.py                 # Inicializa la aplicaciÃ³n Flask
â”‚   â”œâ”€â”€ config.py                   # Configuraciones de la aplicaciÃ³n
â”‚   â”œâ”€â”€ models/                     # Modelos (datos y lÃ³gica de negocio)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth.py                 # Modelo para autenticaciÃ³n y acceso
â”‚   â”‚   â””â”€â”€ game_data.py            # Modelo para datos del juego
â”‚   â”œâ”€â”€ controllers/                # Controladores (lÃ³gica de rutas)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ auth_controller.py      # Controlador para autenticaciÃ³n
â”‚   â”‚   â”œâ”€â”€ admin_controller.py     # Controlador para panel de administraciÃ³n
â”‚   â”‚   â””â”€â”€ room_controller.py      # Controlador para salas y eras
â”‚   â””â”€â”€ views/                      # Vistas (templates)
â”‚       â””â”€â”€ templates/              # Plantillas HTML
â”œâ”€â”€ requirements.txt                # Dependencias
â”œâ”€â”€ wsgi.py                         # Punto de entrada para producciÃ³n
â”œâ”€â”€ run.py                          # Script para ejecutar en desarrollo
â””â”€â”€ render.yaml                     # ConfiguraciÃ³n para deploy en Render
```

## Requisitos

- Python 3.9+
- Flask
- Flask-SocketIO
- Pillow
- qrcode
- gunicorn (producciÃ³n)
- gevent-websocket (producciÃ³n)

## InstalaciÃ³n y ejecuciÃ³n en desarrollo

1. Clonar el repositorio:
```bash
git clone <repo-url>
cd arkham-horror-app
```

2. Crear un entorno virtual e instalar dependencias:
```bash
python -m venv venv
source venv/bin/activate  # En Windows: venv\Scripts\activate
pip install -r requirements.txt
```

3. Ejecutar la aplicaciÃ³n en modo desarrollo:
```bash
python run.py
```

4. Acceder a la aplicaciÃ³n en:
```
http://localhost:5000
```

## Despliegue en producciÃ³n (Render)

1. Subir el cÃ³digo a un repositorio Git (GitHub, GitLab, etc.)

2. Crear un nuevo Web Service en Render:
   - Conectar tu repositorio Git
   - Seleccionar el tipo de entorno: Python
   - Dejar que Render detecte automÃ¡ticamente el comando de construcciÃ³n y arranque basado en render.yaml

3. O configurar manualmente:
   - Build Command: `pip install -r requirements.txt`
   - Start Command: `gunicorn -k geventwebsocket.gunicorn.workers.GeventWebSocketWorker -w 1 wsgi:app`
   - Variables de entorno:
     - `RENDER`: `true`
     - `FLASK_ENV`: `production`

## Acceso a la aplicaciÃ³n

### Acceso como mesa de juego
- Usar el cÃ³digo de mesa proporcionado (formato: mesa01, mesa02, etc.)
- O escanear el cÃ³digo QR generado por el administrador

### Acceso como administrador
- Usuario: admin1, admin2, admin3, admin4, o admin5
- ContraseÃ±a: clave1, clave2, clave3, clave4, o clave5 respectivamente

## CaracterÃ­sticas principales

- AutenticaciÃ³n para mesas y administradores
- Panel de administraciÃ³n para gestionar grupos y mesas
- GeneraciÃ³n de cÃ³digos QR para acceso rÃ¡pido
- ComunicaciÃ³n en tiempo real mediante WebSockets
- GestiÃ³n de recursos, anuncios y contadores del juego


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\render.yaml
--------------------------------------------------
services:
  - type: web
    name: arkham-horror-app
    env: python
    buildCommand: pip install -r requirements.txt
    startCommand: gunicorn -k geventwebsocket.gunicorn.workers.GeventWebSocketWorker -w 1 wsgi:app
    envVars:
      - key: RENDER
        value: true
      - key: FLASK_ENV
        value: production


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\requirements.txt
--------------------------------------------------
flask==2.3.3
flask-socketio==5.3.4
qrcode==7.4.2
pillow==10.0.1
gunicorn==21.2.0
gevent==23.9.1
gevent-websocket==0.10.1
python-engineio==4.7.1
python-socketio==5.9.0


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\run.py
--------------------------------------------------
import os
from app import create_app, socketio

app = create_app()

if __name__ == '__main__':
    # En desarrollo usamos debug=True
    socketio.run(app, debug=True, host='0.0.0.0')


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\wsgi.py
--------------------------------------------------
from app import create_app, socketio

app = create_app()

if __name__ == '__main__':
    socketio.run(app)


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\config.py
--------------------------------------------------
import os
import secrets

class Config:
    """ConfiguraciÃ³n base para la aplicaciÃ³n"""
    SECRET_KEY = os.environ.get('SECRET_KEY') or secrets.token_hex(24)
    TEMPLATES_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'views/templates')
    
class DevelopmentConfig(Config):
    """ConfiguraciÃ³n para entorno de desarrollo"""
    DEBUG = True

class ProductionConfig(Config):
    """ConfiguraciÃ³n para entorno de producciÃ³n"""
    DEBUG = False

# ConfiguraciÃ³n segÃºn el entorno
config_by_name = {
    'development': DevelopmentConfig,
    'production': ProductionConfig
}

# Determinar configuraciÃ³n activa
def get_config():
    env = os.environ.get('FLASK_ENV', 'development')
    if os.environ.get('RENDER', '') == 'true':
        env = 'production'
    return config_by_name[env]


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\__init__.py
--------------------------------------------------
from flask import Flask
from flask_socketio import SocketIO
from .config import get_config

# Inicializar SocketIO antes de la aplicaciÃ³n
socketio = SocketIO(cors_allowed_origins="*")

def create_app():
    """FunciÃ³n para crear y configurar la aplicaciÃ³n Flask"""
    app = Flask(__name__, 
                template_folder='views/templates',
                static_folder='static')
    
    # Aplicar configuraciÃ³n
    app_config = get_config()
    app.config.from_object(app_config)
    
    # Inicializar SocketIO con la aplicaciÃ³n
    socketio.init_app(app)
    
    # Registrar blueprints
    from app.controllers.auth_controller import auth_bp
    from app.controllers.admin_controller import admin_bp
    from app.controllers.room_controller import room_bp
    
    app.register_blueprint(auth_bp)
    app.register_blueprint(admin_bp, url_prefix='/admin')
    app.register_blueprint(room_bp)
    
    return app


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\controllers\admin_controller.py
--------------------------------------------------
from flask import Blueprint, render_template, redirect, url_for, session, flash, request, jsonify, send_file
from app.models.auth import Auth
from app.models.game_data import GameData
from app import socketio
import qrcode
import io
import base64
from PIL import Image, ImageDraw, ImageFont

# Crear blueprint para rutas de administraciÃ³n
admin_bp = Blueprint('admin', __name__)

@admin_bp.route('/admin_panel')
def panel():
    """PÃ¡gina principal del panel de administraciÃ³n"""
    # Verificar que sea un admin
    if 'is_admin' not in session or not session['is_admin']:
        flash('No tienes permiso para acceder al panel de administraciÃ³n.', 'error')
        return redirect(url_for('auth.index'))
    
    return render_template('admin_panel.html', 
                          rooms=Auth.get_all_rooms(), 
                          mesa_access_codes=Auth.get_all_mesa_codes())

@admin_bp.route('/add_room', methods=['POST'])
def add_room():
    """AÃ±ade una nueva sala/grupo"""
    # Verificar si es admin
    if not ('is_admin' in session and session['is_admin']):
        flash('No tienes permiso para aÃ±adir grupos.', 'error')
        return redirect(url_for('auth.index'))
    
    # AÃ±adir nueva sala
    new_room = Auth.add_room()
    
    # Emitir evento de actualizaciÃ³n de salas a todos los administradores
    socketio.emit('room_update', {
        'rooms': Auth.get_all_rooms()
    }, room='admin_room')
    
    flash(f'Grupo {new_room["id"]} creado con Ã©xito junto con sus cÃ³digos de mesa.', 'success')
    return redirect(url_for('admin.panel'))

@admin_bp.route('/reset_server', methods=['POST'])
def reset_server():
    """Resetea todos los datos del servidor"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        flash('No tienes permiso para realizar esta acciÃ³n.', 'error')
        return redirect(url_for('auth.index'))
    
    # Resetear todos los datos del juego
    GameData.reset_all_data()
    
    # Emitir evento de actualizaciÃ³n global
    socketio.emit('server_reset', {
        'message': 'El servidor ha sido reiniciado completamente'
    })
    
    flash('El servidor ha sido reiniciado completamente.', 'success')
    
    # Determinar si la solicitud fue AJAX o normal
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        return jsonify({
            'success': True,
            'message': 'El servidor ha sido reiniciado completamente'
        })
    else:
        return redirect(url_for('admin.panel'))

@admin_bp.route('/reset_perdicion_cycle', methods=['POST'])
def reset_perdicion_cycle():
    """Reinicia el ciclo de perdiciÃ³n"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    # Reiniciar el ciclo y el contador global
    global_counters = GameData.initialize_global_counters()
    global_counters["perdicion_cycle"] = 1
    global_counters["perdicion"] = 0
    
    # Reiniciar el contador de perdiciÃ³n en todas las salas
    for key in GameData._game_data:
        if key.startswith('room_'):
            room_id = int(key.split('_')[1])
            # Obtener los datos de columna de la sala
            column_totals = GameData.initialize_room_column_totals(room_id)
            
            # Reiniciar el contador de perdiciÃ³n en todas las eras
            for era in ["pasado", "presente", "futuro"]:
                column_totals[era]["perdicion"] = 0
                
                # Emitir evento para actualizar la interfaz en todos los clientes de esta sala y era
                socketio.emit('column_resource_update', {
                    'room_id': room_id,
                    'era': era,
                    'columnTotals': column_totals[era],
                    'perdicionCycle': global_counters["perdicion_cycle"]
                }, room=f"room_{room_id}")
    
    # Emitir evento global a todos los clientes conectados
    socketio.emit('global_counter_update', {
        'globalTotals': global_counters,
        'enablePerdicionControls': True
    })
    
    return jsonify({
        "success": True,
        "message": "Ciclo de perdiciÃ³n reiniciado correctamente",
        "globalTotals": global_counters,
        "enablePerdicionControls": True
    })

@admin_bp.route('/generate_qr/<mesa_code>', methods=['GET'])
def generate_qr(mesa_code):
    """Genera un cÃ³digo QR para una mesa especÃ­fica"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        flash('No tienes permiso para realizar esta acciÃ³n.', 'error')
        return redirect(url_for('auth.index'))
    
    # Verificar que el cÃ³digo de mesa exista
    mesa_access_codes = Auth.get_all_mesa_codes()
    if mesa_code not in mesa_access_codes:
        flash('CÃ³digo de mesa invÃ¡lido.', 'error')
        return redirect(url_for('admin.panel'))
    
    # URL del sitio
    site_url = request.url_root
    # URL completa para el cÃ³digo QR (eliminar la barra al final si existe)
    if site_url.endswith('/'):
        site_url = site_url[:-1]
    
    # Texto que se convertirÃ¡ en cÃ³digo QR
    qr_data = f"{site_url}?code={mesa_code}"
    
    # Crear el objeto QR
    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=4,
    )
    
    # Agregar los datos al QR
    qr.add_data(qr_data)
    qr.make(fit=True)
    
    # Crear la imagen QR y asegurarse de que estÃ© en el formato correcto
    qr_img = qr.make_image(fill_color="black", back_color="white")
    qr_img = qr_img.convert('RGB')  # Asegurarse de que estÃ© en modo RGB
    
    # Obtener informaciÃ³n de la mesa
    mesa_info = mesa_access_codes[mesa_code]
    group_id = mesa_info["group"]
    era = mesa_info["era"]
    
    # Crear una imagen mÃ¡s grande con espacio para texto
    img_width, img_height = qr_img.size
    new_img = Image.new('RGB', (img_width, img_height + 60), color='white')
    
    # Pegar el cÃ³digo QR en la nueva imagen
    new_img.paste(qr_img, (0, 0))
    
    # Agregar texto debajo del cÃ³digo QR
    draw = ImageDraw.Draw(new_img)
    
    # Intentar usar una fuente predeterminada, o usar el texto simple si no estÃ¡ disponible
    try:
        # En sistemas Linux
        font = ImageFont.truetype("DejaVuSans.ttf", 18)
    except IOError:
        try:
            # En sistemas Windows
            font = ImageFont.truetype("arial.ttf", 18)
        except IOError:
            # Si no hay fuentes disponibles, usar fuente predeterminada
            font = ImageFont.load_default()
    
    # Texto para mostrar (cÃ³digo de mesa, grupo y era)
    mesa_name = "Mesa " + mesa_code[4:].zfill(2).upper()
    group_name = f"Grupo {group_id}"
    era_name = era.capitalize()
    
    # Dibujar el texto
    draw.text((10, img_height + 5), mesa_name, font=font, fill='black')
    draw.text((10, img_height + 25), f"{group_name} - {era_name}", font=font, fill='black')
    
    # Guardar la imagen en un buffer de bytes
    img_byte_array = io.BytesIO()
    new_img.save(img_byte_array, format='PNG')
    img_byte_array.seek(0)
    
    # Enviar la imagen como respuesta
    return send_file(
        img_byte_array,
        mimetype='image/png',
        as_attachment=True,
        download_name=f'qr_{mesa_code}.png'
    )

@admin_bp.route('/print_all_qr', methods=['GET'])
def print_all_qr():
    """Genera todos los cÃ³digos QR en una sola pÃ¡gina para imprimir"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        flash('No tienes permiso para realizar esta acciÃ³n.', 'error')
        return redirect(url_for('auth.index'))
    
    # URL del sitio
    site_url = request.url_root
    # URL completa para el cÃ³digo QR (eliminar la barra al final si existe)
    if site_url.endswith('/'):
        site_url = site_url[:-1]
    
    # Generar cÃ³digos QR para todas las mesas
    mesa_qr_data = {}
    mesa_access_codes = Auth.get_all_mesa_codes()
    
    for mesa_code in mesa_access_codes:
        # Texto que se convertirÃ¡ en cÃ³digo QR
        qr_data = f"{site_url}?code={mesa_code}"
        
        # Crear el objeto QR
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        
        # Agregar los datos al QR
        qr.add_data(qr_data)
        qr.make(fit=True)
        
        # Crear la imagen QR y asegurarse de que estÃ© en el formato correcto
        qr_img = qr.make_image(fill_color="black", back_color="white")
        qr_img = qr_img.convert('RGB')  # Asegurarse de que estÃ© en modo RGB
        
        # Obtener informaciÃ³n de la mesa
        mesa_info = mesa_access_codes[mesa_code]
        group_id = mesa_info["group"]
        era = mesa_info["era"]
        
        # Crear una imagen mÃ¡s grande con espacio para texto
        img_width, img_height = qr_img.size
        new_img = Image.new('RGB', (img_width, img_height + 60), color='white')
        
        # Pegar el cÃ³digo QR en la nueva imagen
        new_img.paste(qr_img, (0, 0))
        
        # Agregar texto debajo del cÃ³digo QR
        draw = ImageDraw.Draw(new_img)
        
        # Intentar usar una fuente predeterminada
        try:
            # En sistemas Linux
            font = ImageFont.truetype("DejaVuSans.ttf", 18)
        except IOError:
            try:
                # En sistemas Windows
                font = ImageFont.truetype("arial.ttf", 18)
            except IOError:
                # Si no hay fuentes disponibles, usar fuente predeterminada
                font = ImageFont.load_default()
        
        # Texto para mostrar (cÃ³digo de mesa, grupo y era)
        mesa_name = "Mesa " + mesa_code[4:].zfill(2).upper()
        group_name = f"Grupo {group_id}"
        era_name = era.capitalize()
        
        # Dibujar el texto
        draw.text((10, img_height + 5), mesa_name, font=font, fill='black')
        draw.text((10, img_height + 25), f"{group_name} - {era_name}", font=font, fill='black')
        
        # Convertir la imagen a base64 para mostrarla en HTML
        img_byte_array = io.BytesIO()
        new_img.save(img_byte_array, format='PNG')
        img_byte_array.seek(0)
        img_base64 = base64.b64encode(img_byte_array.getvalue()).decode('utf-8')
        
        # Guardar los datos del QR
        mesa_qr_data[mesa_code] = {
            'img_base64': img_base64,
            'mesa_name': mesa_name,
            'group_name': group_name,
            'era_name': era_name
        }
    
    # Renderizar la pÃ¡gina con todos los cÃ³digos QR
    return render_template('print_qr.html', mesa_qr_data=mesa_qr_data)


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\controllers\auth_controller.py
--------------------------------------------------
from flask import Blueprint, render_template, request, redirect, url_for, session, flash
from app.models.auth import Auth

# Crear blueprint para rutas de autenticaciÃ³n
auth_bp = Blueprint('auth', __name__)

@auth_bp.route('/', methods=['GET', 'POST'])
def index():
    """Gestiona la pantalla de login principal"""
    # Verificar si hay un cÃ³digo en la URL (para escaneo de QR)
    if request.method == 'GET' and 'code' in request.args:
        access_code = request.args.get('code', '').strip().lower()
        
        mesa_data = Auth.get_mesa_info(access_code)
        if mesa_data:
            # CÃ³digo vÃ¡lido, asignar al grupo y era correspondiente
            group_id = mesa_data["group"]
            era = mesa_data["era"]
            session['assigned_group'] = group_id
            session['assigned_era'] = era
            session['is_admin'] = False
            session['mesa_code'] = access_code
            return redirect(url_for('game.era', room_id=group_id, era=era))
        else:
            # CÃ³digo invÃ¡lido
            flash('CÃ³digo de acceso invÃ¡lido. Por favor, intenta nuevamente.', 'error')
    
    if request.method == 'POST':
        # Si se enviÃ³ un cÃ³digo de mesa
        if 'access_code' in request.form:
            access_code = request.form.get('access_code', '').strip().lower()
            
            mesa_data = Auth.get_mesa_info(access_code)
            if mesa_data:
                # CÃ³digo vÃ¡lido, asignar al grupo y era correspondiente
                group_id = mesa_data["group"]
                era = mesa_data["era"]
                session['assigned_group'] = group_id
                session['assigned_era'] = era
                session['is_admin'] = False
                session['mesa_code'] = access_code
                return redirect(url_for('game.era', room_id=group_id, era=era))
            else:
                # CÃ³digo invÃ¡lido
                flash('CÃ³digo de acceso invÃ¡lido. Por favor, intenta nuevamente.', 'error')
        
        # Si se enviaron credenciales de administrador
        elif 'admin_username' in request.form and 'admin_password' in request.form:
            username = request.form.get('admin_username', '').strip()
            password = request.form.get('admin_password', '').strip()
            
            if Auth.validate_admin(username, password):
                # Admin vÃ¡lido
                session['is_admin'] = True
                session.pop('assigned_group', None)  # Eliminar grupo especÃ­fico ya que es admin
                session.pop('assigned_era', None)    # Eliminar era especÃ­fica ya que es admin
                session.pop('mesa_code', None)       # Eliminar cÃ³digo de mesa ya que es admin
                return redirect(url_for('admin.panel'))
            else:
                # Credenciales invÃ¡lidas
                flash('Credenciales de administrador invÃ¡lidas.', 'error')
    
    # Si el usuario ya tiene una sesiÃ³n
    if 'is_admin' in session and session['is_admin']:
        return redirect(url_for('admin.panel'))
    elif 'assigned_group' in session and 'assigned_era' in session:
        return redirect(url_for('game.era', room_id=session['assigned_group'], era=session['assigned_era']))
    
    return render_template('login.html')

@auth_bp.route('/logout')
def logout():
    """Gestiona el cierre de sesiÃ³n"""
    # Simplemente limpiar todas las variables de sesiÃ³n
    # No intentamos usar leave_room aquÃ­ ya que puede causar errores
    # La desconexiÃ³n de Socket.IO se maneja automÃ¡ticamente cuando el cliente se desconecta
    session.clear()
    
    # Redireccionar a la pÃ¡gina de inicio
    return redirect(url_for('auth.index'))


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\controllers\room_controller - copia.py
--------------------------------------------------
from flask import Blueprint, render_template, redirect, url_for, session, flash, request, jsonify
from app.models.auth import Auth
from app.models.game_data import GameData
from app import socketio
from flask_socketio import emit, join_room, leave_room
import traceback

# Crear blueprint para rutas de sala y eras
room_bp = Blueprint('game', __name__)
@room_bp.route('/room/<int:room_id>')
def room(room_id):
    """Vista de selecciÃ³n de eras en una sala"""
    # Solo los administradores pueden acceder a la vista de selecciÃ³n de eras
    if not ('is_admin' in session and session['is_admin']):
        flash('No tienes permiso para acceder a esta pÃ¡gina.', 'error')
        
        # Si el usuario tiene una era asignada, redirigirlo allÃ­
        if 'assigned_group' in session and 'assigned_era' in session:
            return redirect(url_for('game.era', room_id=session['assigned_group'], era=session['assigned_era']))
        else:
            return redirect(url_for('auth.index'))
    
    room = Auth.get_room_by_id(room_id)
    if not room:
        return redirect(url_for('auth.index'))
    
    return render_template('room.html', room=room, is_admin='is_admin' in session and session['is_admin'])

@room_bp.route('/era/<int:room_id>/<era>')
def era(room_id, era):
    """Vista de una era especÃ­fica en una sala"""
    # Verificar acceso
    if 'is_admin' in session and session['is_admin']:
        # Los admins pueden acceder a cualquier era de cualquier grupo
        pass
    elif 'assigned_group' in session and 'assigned_era' in session:
        # Verificar que el usuario solo pueda acceder a su grupo y era asignada
        if session['assigned_group'] != room_id or session['assigned_era'] != era:
            flash('No tienes permiso para acceder a este grupo o era.', 'error')
            return redirect(url_for('game.era', room_id=session['assigned_group'], era=session['assigned_era']))
    else:
        flash('No tienes permiso para acceder a esta pÃ¡gina.', 'error')
        return redirect(url_for('auth.index'))
    
    if era not in ["pasado", "presente", "futuro"]:
        if 'assigned_era' in session:
            return redirect(url_for('game.era', room_id=room_id, era=session['assigned_era']))
        else:
            return redirect(url_for('auth.index'))
    
    room = Auth.get_room_by_id(room_id)
    if not room:
        return redirect(url_for('auth.index'))
    
    # Inicializar o cargar datos de la sala
    room_data = GameData.initialize_room_data(room_id)
    progress = room_data["progress"]
    resources = room_data["resources"]
    biff_defeats = room_data["biff_defeats"]
    
    # Verificar cuÃ¡les botones estÃ¡n disponibles segÃºn las dependencias
    available_buttons = []
    for i in range(len(GameData.button_info[era])):
        is_available = True
        for dep in GameData.button_dependencies[era][i]:
            dep_era, dep_idx = dep.split('-')
            dep_idx = int(dep_idx)
            if not progress[dep_era][dep_idx]:
                is_available = False
                break
        available_buttons.append(is_available)
    
    # Obtener el nombre de la mesa si aplica
    mesa_name = ""
    if 'mesa_code' in session:
        mesa_code = session['mesa_code']
        # Convertir mesa01 a Mesa 01
        mesa_name = "Mesa " + mesa_code[4:].zfill(2).upper()
    
    # Obtener el ciclo actual de perdiciÃ³n
    global_counters = GameData.initialize_global_counters()
    perdicion_cycle = global_counters["perdicion_cycle"]
    
    # Inicializar columnas de la sala
    column_totals = GameData.initialize_room_column_totals(room_id)
    
    return render_template('era.html', 
                          room=room, 
                          era=era, 
                          progress=progress,
                          button_info=GameData.button_info[era],
                          available_buttons=available_buttons,
                          resources=resources,
                          biff_defeats=biff_defeats[era],
                          mesa_name=mesa_name,
                          perdicion_cycle=perdicion_cycle,
                          column_totals=column_totals[era],
                          is_admin='is_admin' in session and session['is_admin'])

@room_bp.route('/toggle_button/<int:room_id>/<era>/<int:button_idx>', methods=['POST'])
def toggle_button(room_id, era, button_idx):
    """Activa o desactiva un botÃ³n de anuncio"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        flash('No tienes permiso para realizar esta acciÃ³n.', 'error')
        return redirect(url_for('auth.index'))
    
    if era not in ["pasado", "presente", "futuro"]:
        if 'assigned_era' in session:
            return redirect(url_for('game.era', room_id=room_id, era=session['assigned_era']))
        else:
            return redirect(url_for('auth.index'))
    
    try:
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Determinar si estamos activando o desactivando el botÃ³n
        is_activating = not room_data["progress"][era][button_idx]
        
        # Si es admin, permitir activar cualquier botÃ³n sin restricciones
        if 'is_admin' in session and session['is_admin']:
            # Si estamos desactivando, desactivar tambiÃ©n los dependientes
            if not is_activating:
                # Primero, cambiamos el estado del botÃ³n principal
                room_data["progress"][era][button_idx] = False
                
                # Luego desactivamos todos los que dependen de este
                deactivate_dependent_buttons(room_data["progress"], f"{era}-{button_idx}")
            else:
                # Si estamos activando, simplemente activamos este botÃ³n
                room_data["progress"][era][button_idx] = True
        else:
            # Verificar si se cumplen las dependencias para activar
            if is_activating:
                can_toggle = True
                for dep in GameData.button_dependencies[era][button_idx]:
                    dep_era, dep_idx = dep.split('-')
                    dep_idx = int(dep_idx)
                    if not room_data["progress"][dep_era][dep_idx]:
                        can_toggle = False
                        break
                
                if can_toggle:
                    # Cambiar el estado del botÃ³n (activar)
                    room_data["progress"][era][button_idx] = True
            else:
                # Si estÃ¡ desactivando, verificar y desactivar dependientes
                room_data["progress"][era][button_idx] = False
                deactivate_dependent_buttons(room_data["progress"], f"{era}-{button_idx}")
        
        # Verificar todos los botones en todas las eras para determinar las dependencias correctamente
        all_available_buttons = get_available_buttons(room_data["progress"])
        
        # Emitir evento de actualizaciÃ³n a todos los clientes en la sala
        socketio.emit('button_update', {
            'room_id': room_id,
            'era': era,
            'progress': room_data["progress"],
            'available_buttons': all_available_buttons,
            'button_idx': button_idx,  # Enviar quÃ© botÃ³n especÃ­fico se ha cambiado
            'is_activating': is_activating  # Indicar si se estÃ¡ activando o desactivando
        }, room=f"room_{room_id}")
        
        # Determinar si la solicitud fue AJAX o normal
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({
                'success': True,
                'message': 'BotÃ³n actualizado correctamente',
                'progress': room_data["progress"],
                'available_buttons': all_available_buttons
            })
        else:
            return redirect(url_for('game.era', room_id=room_id, era=era))
    except Exception as e:
        error_msg = f"Error al actualizar botÃ³n: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({
                'success': False,
                'error': error_msg
            })
        else:
            flash(error_msg, 'error')
            return redirect(url_for('game.era', room_id=room_id, era=era))

@room_bp.route('/update_resources/<int:room_id>/<era>', methods=['POST'])
def update_resources(room_id, era):
    """Actualiza los recursos de una era"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos de recursos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        resource_amount = data.get('amount', 0)
        
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Actualizar los recursos
        room_data["resources"][era] += resource_amount
        room_data["resources"]["total"] += resource_amount
        
        # Emitir evento de actualizaciÃ³n de recursos a todos los clientes en la sala
        socketio.emit('resource_update', {
            'room_id': room_id,
            'resources': room_data["resources"]
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "resources": room_data["resources"]
        })
    except Exception as e:
        error_msg = f"Error al actualizar recursos: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

# FunciÃ³n interna para ajustar todos los valores de fluzo
def adjust_all_fluzo_values_internal():
    """Ajusta los valores de fluzo en todas las salas segÃºn las reglas especificadas (funciÃ³n interna)"""
    try:
        # Obtener todas las salas con datos
        room_ids = []
        for key in GameData._game_data.keys():
            if key.startswith("room_"):
                room_id = int(key.split("_")[1])
                room_ids.append(room_id)
        
        # Para cada sala, ajustar los valores de fluzo en todas las eras
        for room_id in room_ids:
            for era in ["pasado", "presente", "futuro"]:
                # Obtener los datos de la sala
                column_totals = GameData.initialize_room_column_totals(room_id)
                
                # Asegurarse de que fluzo existe en los datos
                if "fluzo" not in column_totals[era]:
                    column_totals[era]["fluzo"] = 0
                
                # Obtener el valor actual
                current_fluzo = column_totals[era]["fluzo"]
                new_fluzo = current_fluzo
                
                # Aplicar las reglas de ajuste:
                if current_fluzo > 86:
                    new_fluzo = current_fluzo - 10
                elif current_fluzo < 76:
                    new_fluzo = current_fluzo + 10
                elif current_fluzo >= 80 and current_fluzo <= 82:
                    new_fluzo = current_fluzo - 5
                
                # Solo actualizar si el valor ha cambiado
                if new_fluzo != current_fluzo:
                    # Actualizar el valor en la sala
                    column_totals[era]["fluzo"] = new_fluzo
                    
                    # Guardar los cambios
                    GameData.save_column_totals(room_id, column_totals)
                    
                    # Emitir evento de actualizaciÃ³n
                    socketio.emit('fluzo_update', {
                        'room_id': room_id,
                        'era': era,
                        'fluzoTotal': new_fluzo,
                        'fluzoValue': 0,  # La caja siempre muestra 0
                        #'message': "El nivel de Fluzo condensado ha sido alterado"
                    }, room=f"room_{room_id}")
        
        return True
    except Exception as e:
        print(f"Error al ajustar valores de fluzo internamente: {str(e)}")
        traceback.print_exc()
        return False

@room_bp.route('/adjust_all_fluzo_values', methods=['POST'])
def adjust_all_fluzo_values():
    """Ajusta los valores de fluzo en todas las salas segÃºn las reglas especificadas"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    try:
        success = adjust_all_fluzo_values_internal()
        
        if success:
            return jsonify({
                "success": True,
                "message": "Valores de fluzo ajustados en todas las salas"
            })
        else:
            return jsonify({
                "success": False,
                "error": "Error al ajustar los valores de fluzo"
            })
    except Exception as e:
        error_msg = f"Error al ajustar valores de fluzo: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/biff_defeat/<int:room_id>/<era>', methods=['POST'])
def biff_defeat(room_id, era):
    """Incrementa el contador de derrotas de Biff"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Obtener el ciclo actual de perdiciÃ³n
        global_counters = GameData.initialize_global_counters()
        current_cycle = global_counters["perdicion_cycle"]
        is_plan_1a = (current_cycle == 1)
        
        # Obtener el nÃºmero actual de derrotas y sumamos 1 para obtener la nueva cantidad
        current_defeats = room_data["biff_defeats"][era]
        new_defeats = current_defeats + 1
        
        # Determinar el mensaje segÃºn el nÃºmero de derrotas
        biff_message = ""
        
        if new_defeats == 1:
            biff_message = "\"Â¡Hey, McFly!\" Biff Tannen aparece agotado. Si en la partida esta Marty McFly, aparece en el Lugar de Marty, ignorando sus instrucciones de ApariciÃ³n"
        elif new_defeats == 2:
            biff_message = "\"Â¿Te estoy haciendo perder el tiempo?\": en lugar de derrotar a Biff Tannen, agÃ³talo. No se considera que haya sido derrotado."
        elif new_defeats == 3:
            biff_message = "\"Â¿Te estoy despistando?\": cada investigador debe colocar una de sus pistas sobre su Lugar, o bien recibir 1 punto de horror."
        elif new_defeats == 4:
            biff_message = "\"Â¡Llevo mucho tiempo preparando esto!\": Decides seguir el rastro que ha dejado Biff durante sus viajes en el tiempo. Coloca 1 pista (de la reserva de fichas) sobre cada Lugar en juego."
        elif new_defeats >= 5:
            # A partir de la quinta derrota (incluida)
            if not is_plan_1a:
                # Si NO estamos en Plan 1a, siempre mostrar este mensaje
                biff_message = "Dale la vuelta a Biff Tannen y aÃ±adelo a la zona de victoria."
            else:
                # Si estamos en Plan 1a, depende del nÃºmero exacto de derrotas
                if new_defeats == 5:
                    biff_message = "\"Deja de golpearte, deja de golpearte, deja de golpearte\": Realiza una prueba de <span style=\"font-family: 'AHLCG';\">S</span>(2). Por cada punto que falte para tener Ã©xito, recibe 1 punto de daÃ±o."
                elif new_defeats == 6:
                    biff_message = "\"Â¡Tenemos tiempo de sobra!\": aÃ±ade 1 ficha de PerdiciÃ³n al Plan en curso."
                elif new_defeats == 7:
                    biff_message = "\"Â¡Ya no vas a necesitar esto!\": El investigador que ha derrotado a Biff descarta 1 Apoyo que controle, a ser posible un Apoyo usado para derrotar a Biff Tannen."
                else:  # 8 o mÃ¡s derrotas
                    # Seleccionar mensaje aleatorio entre los 3 disponibles
                    import random
                    random_messages = [
                        "\"Deja de golpearte, deja de golpearte, deja de golpearte\": Realiza una prueba de <span style=\"font-family: 'AHLCG';\">S</span>(2). Por cada punto que falte para tener Ã©xito, recibe 1 punto de daÃ±o.",
                        "\"Â¡Tenemos tiempo de sobra!\": aÃ±ade 1 ficha de PerdiciÃ³n al Plan en curso.",
                        "\"Â¡Ya no vas a necesitar esto!\": El investigador que ha derrotado a Biff descarta 1 Apoyo que controle, a ser posible un Apoyo usado para derrotar a Biff Tannen."
                    ]
                    biff_message = random.choice(random_messages)
        
        # Incrementar el contador de derrotas de Biff (sin lÃ­mite)
        room_data["biff_defeats"][era] += 1
        
        # Emitir evento de actualizaciÃ³n a todos los clientes en la sala
        socketio.emit('biff_update', {
            'room_id': room_id,
            'era': era,
            'defeats': room_data["biff_defeats"][era],
            'message': biff_message  # AÃ±adir el mensaje a la respuesta
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "defeats": room_data["biff_defeats"][era],
            "message": biff_message  # AÃ±adir el mensaje a la respuesta
        })
    except Exception as e:
        error_msg = f"Error al actualizar derrotas de Biff: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/update_column_resource/<int:room_id>/<era>/<column>', methods=['POST'])
def update_column_resource(room_id, era, column):
    """Actualiza un contador de columna especÃ­fico"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    if column not in ["perdicion", "reserva", "fluzo"]:  # AÃ±adido fluzo a las columnas permitidas
        return jsonify({"success": False, "error": "Columna invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        amount = data.get('amount', 0)
        
        # Inicializar datos de la sala y contadores
        room_data = GameData.initialize_room_data(room_id)
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # MODIFICACIÃ“N: LÃ³gica para valores negativos en PerdiciÃ³n
        if column == "perdicion" and amount < 0:
            # Verificar que el valor global no se vuelva negativo
            new_global_value = global_counters["perdicion"] + amount
            
            if new_global_value < 0:
                # Limitar la reducciÃ³n para que el total sea 0
                amount = -global_counters["perdicion"]
                new_global_value = 0
        
        # Variable para controlar si estamos completando un ciclo
        cycle_completed = False
        notification = None
        
        # LÃ³gica especial para perdiciÃ³n
        if column == "perdicion":
            # Si estamos en el ciclo 3 y ya ha terminado, no permitimos mÃ¡s cambios
            if global_counters["perdicion_cycle"] > 3:
                return jsonify({
                    "success": False,
                    "error": "El contador de perdiciÃ³n ha completado todos sus ciclos."
                })
            
            # Calculamos el nuevo valor despuÃ©s del cambio
            new_perdicion_value = global_counters["perdicion"] + amount
            
            # Verificar que el nuevo valor no sea negativo
            if new_perdicion_value < 0:
                new_perdicion_value = 0
                # Ajustar la cantidad para que el contador de la sala tambiÃ©n se actualice correctamente
                amount = -global_counters["perdicion"]
                
            # Verificar lÃ­mites segÃºn el ciclo actual
            cycle_limits = {1: 5, 2: 4, 3: 5}
            current_cycle = global_counters["perdicion_cycle"]
            
            # Si alcanzamos o superamos el lÃ­mite del ciclo actual
            if current_cycle in cycle_limits and new_perdicion_value >= cycle_limits[current_cycle]:
                # Enviamos una notificaciÃ³n segÃºn el ciclo
                notifications = {
                    1: "Haz avanzar al Plan 1b",
                    2: "Haz avanzar al Plan 1b. El valor de Fluzo ha sido alterado",
                    3: "(->R2)"
                }
                notification = notifications[current_cycle]
                
                # Actualizamos el ciclo y reseteamos el contador global
                global_counters["perdicion_cycle"] += 1
                global_counters["perdicion"] = 0
                
                # Marcamos que se completÃ³ un ciclo
                cycle_completed = True
                
                # Reiniciamos los contadores de perdiciÃ³n para todas las salas
                # 1. Reiniciamos los contadores de la sala actual
                for reset_era in ["pasado", "presente", "futuro"]:
                    column_totals[reset_era]["perdicion"] = 0
                
                # 2. Guardar en la sala actual
                GameData.save_column_totals(room_id, column_totals)
                
                # 3. Reiniciar contadores de perdiciÃ³n en TODAS las salas
                GameData.reset_perdicion_all_rooms()
                
                # 4. Si estamos pasando del ciclo 2 al ciclo 3, ajustar valores de fluzo
                if current_cycle == 2:
                    # Llamar a la funciÃ³n para ajustar todos los valores de fluzo
                    adjust_all_fluzo_values_internal()
            else:
                # Si no alcanzamos el lÃ­mite, actualizamos normalmente
                global_counters["perdicion"] = new_perdicion_value
                column_totals[era][column] += amount
        elif column == "fluzo":
            # Para fluzo, simplemente actualizamos el valor en la sala
            column_totals[era][column] += amount
        else:
            # Para otros contadores (reserva) actualizamos normalmente
            # TambiÃ©n evitamos valores negativos para la reserva global
            new_value = global_counters[column] + amount
            if new_value < 0:
                new_value = 0
                # Ajustar la cantidad para que el contador de la sala tambiÃ©n se actualice correctamente
                amount = -global_counters[column]
            
            global_counters[column] = new_value
            
            # TambiÃ©n evitamos valores negativos para el contador de la sala
            new_room_value = column_totals[era][column] + amount
            if new_room_value < 0:
                new_room_value = 0
                amount = -column_totals[era][column]
            
            column_totals[era][column] = new_room_value
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        GameData.save_global_counters(global_counters)
        
        # Emitir eventos segÃºn corresponda
        if cycle_completed:
            # Si se completÃ³ un ciclo, enviar un evento a TODAS las mesas en TODAS las salas
            # Este evento forzarÃ¡ la actualizaciÃ³n de todos los contadores de perdiciÃ³n
            socketio.emit('perdicion_cycle_completed', {
                'perdicionCycle': global_counters["perdicion_cycle"],
                'notification': notification,
                'originRoom': room_id,
                'originEra': era
            })
        else:
            # Comportamiento normal - enviar solo para la era actual
            socketio.emit('column_resource_update', {
                'room_id': room_id,
                'era': era,
                'columnTotals': column_totals[era],
                'notification': notification,
                'perdicionCycle': global_counters["perdicion_cycle"]
            }, room=f"room_{room_id}")
        
        # Emitir evento global a todos los clientes conectados
        socketio.emit('global_counter_update', {
            'globalTotals': global_counters,
            'notification': notification,
            'cycleCompleted': cycle_completed
        })
        
        return jsonify({
            "success": True,
            "columnTotals": column_totals[era],
            "globalTotals": global_counters,
            "notification": notification
        })
    except Exception as e:
        error_msg = f"Error al actualizar columna: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

# Controlador para PerdiciÃ³n
@room_bp.route('/update_perdicion/<int:room_id>/<era>', methods=['POST'])
def update_perdicion(room_id, era):
    """Actualiza especÃ­ficamente el contador de perdiciÃ³n"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        amount = data.get('amount', 0)
        
        # Inicializar datos de la sala y contadores
        room_data = GameData.initialize_room_data(room_id)
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # LÃ³gica para valores negativos en PerdiciÃ³n
        if amount < 0:
            # Verificar que el valor global no se vuelva negativo
            new_global_value = global_counters["perdicion"] + amount
            
            if new_global_value < 0:
                # Limitar la reducciÃ³n para que el total sea 0
                amount = -global_counters["perdicion"]
                new_global_value = 0
        
        # Variable para controlar si estamos completando un ciclo
        cycle_completed = False
        notification = None
        
        # Si estamos en el ciclo 3 y ya ha terminado, no permitimos mÃ¡s cambios
        if global_counters["perdicion_cycle"] > 3:
            return jsonify({
                "success": False,
                "error": "El contador de perdiciÃ³n ha completado todos sus ciclos."
            })
        
        # Calculamos el nuevo valor despuÃ©s del cambio
        new_perdicion_value = global_counters["perdicion"] + amount
        
        # Verificar que el nuevo valor no sea negativo
        if new_perdicion_value < 0:
            new_perdicion_value = 0
            # Ajustar la cantidad para que el contador de la sala tambiÃ©n se actualice correctamente
            amount = -global_counters["perdicion"]
            
        # Verificar lÃ­mites segÃºn el ciclo actual
        cycle_limits = {1: 5, 2: 4, 3: 5}
        current_cycle = global_counters["perdicion_cycle"]
        
        # Si alcanzamos o superamos el lÃ­mite del ciclo actual
        if current_cycle in cycle_limits and new_perdicion_value >= cycle_limits[current_cycle]:
            # Enviamos una notificaciÃ³n segÃºn el ciclo
            notifications = {
                1: "Haz avanzar al Plan 1b",
                2: "Haz avanzar al Plan 1b. El valor de Fluzo ha sido alterado",
                3: "(->R4)"
            }
            notification = notifications[current_cycle]
            
            # Actualizamos el ciclo y reseteamos el contador global
            global_counters["perdicion_cycle"] += 1
            global_counters["perdicion"] = 0
            
            # Marcamos que se completÃ³ un ciclo
            cycle_completed = True
            
            # Reiniciamos los contadores de perdiciÃ³n para todas las salas
            # 1. Reiniciamos los contadores de la sala actual
            for reset_era in ["pasado", "presente", "futuro"]:
                column_totals[reset_era]["perdicion"] = 0
            
            # 2. Guardar en la sala actual
            GameData.save_column_totals(room_id, column_totals)
            
            # 3. Reiniciar contadores de perdiciÃ³n en TODAS las salas
            GameData.reset_perdicion_all_rooms()
            
            # 4. Si estamos pasando del ciclo 2 al ciclo 3, ajustar valores de fluzo
            if current_cycle == 2:
                # Llamar a la funciÃ³n para ajustar todos los valores de fluzo
                adjust_all_fluzo_values_internal()
        else:
            # Si no alcanzamos el lÃ­mite, actualizamos normalmente
            global_counters["perdicion"] = new_perdicion_value
            column_totals[era]["perdicion"] += amount
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        GameData.save_global_counters(global_counters)
        
        # Emitir eventos segÃºn corresponda
        if cycle_completed:
            # Si se completÃ³ un ciclo, enviar un evento a TODAS las mesas en TODAS las salas
            socketio.emit('perdicion_cycle_completed', {
                'perdicionCycle': global_counters["perdicion_cycle"],
                'notification': notification,
                'originRoom': room_id,
                'originEra': era
            })
        else:
            # Comportamiento normal - enviar solo para la era actual
            socketio.emit('perdicion_update', {
                'room_id': room_id,
                'era': era,
                'columnTotal': column_totals[era]["perdicion"],
                'notification': notification,
                'perdicionCycle': global_counters["perdicion_cycle"]
            }, room=f"room_{room_id}")
        
        # Emitir evento global a todos los clientes conectados
        socketio.emit('global_perdicion_update', {
            'globalTotal': global_counters["perdicion"],
            'perdicionCycle': global_counters["perdicion_cycle"],
            'notification': notification,
            'cycleCompleted': cycle_completed
        })
        
        return jsonify({
            "success": True,
            "columnTotal": column_totals[era]["perdicion"],
            "globalTotal": global_counters["perdicion"],
            "perdicionCycle": global_counters["perdicion_cycle"],
            "notification": notification
        })
    except Exception as e:
        error_msg = f"Error al actualizar perdiciÃ³n: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

# Controlador para Reserva
@room_bp.route('/update_reserva/<int:room_id>/<era>', methods=['POST'])
def update_reserva(room_id, era):
    """Actualiza especÃ­ficamente el contador de reserva"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        amount = data.get('amount', 0)
        
        # Inicializar datos de la sala y contadores
        room_data = GameData.initialize_room_data(room_id)
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # MODIFICACIÃ“N: LÃ³gica para valores negativos en Reserva
        if amount < 0:
            # Verificar que el valor global no se vuelva negativo
            new_global_value = global_counters["reserva"] + amount
            
            if new_global_value < 0:
                # Limitar la reducciÃ³n para que el total sea 0
                amount = -global_counters["reserva"]
                new_global_value = 0
            
            global_counters["reserva"] = new_global_value
        else:
            # Si es un valor positivo, simplemente sumarlo
            global_counters["reserva"] += amount
        
        # IMPORTANTE: Permitir valores negativos en el contador de la sala
        # Actualizar el valor de la sala directamente sin forzar que sea positivo
        column_totals[era]["reserva"] += amount
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        GameData.save_global_counters(global_counters)
        
        # Emitir evento de actualizaciÃ³n a la sala actual
        socketio.emit('reserva_update', {
            'room_id': room_id,
            'era': era,
            'columnTotal': column_totals[era]["reserva"]
        }, room=f"room_{room_id}")
        
        # Emitir evento global a todos los clientes conectados
        socketio.emit('global_reserva_update', {
            'globalTotal': global_counters["reserva"]
        })
        
        return jsonify({
            "success": True,
            "columnTotal": column_totals[era]["reserva"],
            "globalTotal": global_counters["reserva"]
        })
    except Exception as e:
        error_msg = f"Error al actualizar reserva: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

# Controlador para Fluzo
@room_bp.route('/update_fluzo/<int:room_id>/<era>', methods=['POST'])
def update_fluzo(room_id, era):
    """Actualiza especÃ­ficamente el contador de fluzo"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        amount = data.get('amount', 0)
        
        # Inicializar datos de la sala
        column_totals = GameData.initialize_room_column_totals(room_id)
        
        # Asegurarse de que fluzo existe en los datos de la columna
        if "fluzo" not in column_totals[era]:
            column_totals[era]["fluzo"] = 0
        
        # Actualizar valor de fluzo en la sala
        column_totals[era]["fluzo"] += amount
        
        # Si el valor se vuelve negativo, establecerlo a 0
        if column_totals[era]["fluzo"] < 0:
            column_totals[era]["fluzo"] = 0
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        
        # Emitir evento de actualizaciÃ³n a la sala actual
        socketio.emit('fluzo_update', {
            'room_id': room_id,
            'era': era,
            'fluzoTotal': column_totals[era]["fluzo"],
            'fluzoValue': 0,  # La caja siempre muestra 0
            'isRandomValue': True  # Indicar que este es un valor aleatorio
        }, room=f"room_{room_id}")

        return jsonify({
            "success": True,
            "fluzoTotal": column_totals[era]["fluzo"],
            "fluzoValue": 0  # Siempre devolver 0 para la caja
        })
    except Exception as e:
        error_msg = f"Error al actualizar fluzo: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/get_column_totals/<int:room_id>/<era>', methods=['GET'])
def get_column_totals(room_id, era):
    """Obtiene los totales de columna para una era especÃ­fica"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Inicializar datos de la sala y contadores
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        return jsonify({
            "success": True,
            "columnTotals": column_totals[era],
            "globalTotals": global_counters
        })
    except Exception as e:
        error_msg = f"Error al obtener totales de columna: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/get_global_counters', methods=['GET'])
def get_global_counters():
    """Obtiene los contadores globales"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and 'assigned_group' not in session:
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    try:
        # Inicializar contadores globales
        global_counters = GameData.initialize_global_counters()
        
        # Asegurar que consecuencias_imprevistas existe en los contadores
        if "consecuencias_imprevistas" not in global_counters:
            global_counters["consecuencias_imprevistas"] = False
            GameData.save_global_counters(global_counters)
        
        return jsonify({
            "success": True,
            "globalTotals": global_counters
        })
    except Exception as e:
        error_msg = f"Error al obtener contadores globales: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/reset_announcements/<int:room_id>/<era>', methods=['POST'])
def reset_announcements(room_id, era):
    """Resetea todos los anuncios de una era especÃ­fica"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Resetear todos los anuncios de esta era
        for i in range(len(room_data["progress"][era])):
            room_data["progress"][era][i] = False
        
        # Verificar todos los botones para actualizar las dependencias
        all_available_buttons = get_available_buttons(room_data["progress"])
        
        # Emitir evento de actualizaciÃ³n a todos los clientes en la sala
        socketio.emit('button_update', {
            'room_id': room_id,
            'era': era,
            'progress': room_data["progress"],
            'available_buttons': all_available_buttons
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "message": "Anuncios reseteados correctamente"
        })
    except Exception as e:
        error_msg = f"Error al resetear anuncios: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/reset_biff/<int:room_id>/<era>', methods=['POST'])
def reset_biff(room_id, era):
    """Resetea el contador de derrotas de Biff para una era especÃ­fica"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Resetear el contador de Biff
        room_data["biff_defeats"][era] = 0
        
        # Emitir evento de actualizaciÃ³n a todos los clientes en la sala
        socketio.emit('biff_update', {
            'room_id': room_id,
            'era': era,
            'defeats': 0
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "message": "Contador de Biff reseteado correctamente"
        })
    except Exception as e:
        error_msg = f"Error al resetear contador de Biff: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/reset_column/<int:room_id>/<column>', methods=['POST'])
def reset_column(room_id, column):
    """Resetea un contador de columna especÃ­fico en todas las eras"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if column not in ["perdicion", "reserva"]:
        return jsonify({"success": False, "error": "Columna invÃ¡lida"})
    
    try:
        # Inicializar datos de la sala
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # Resetear la columna en todas las eras
        for era in ["pasado", "presente", "futuro"]:
            column_totals[era][column] = 0
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        
        # Resetear tambiÃ©n el contador global si corresponde
        if column in global_counters:
            global_counters[column] = 0
            GameData.save_global_counters(global_counters)
        
        # Emitir eventos de actualizaciÃ³n a todos los clientes en la sala
        for era in ["pasado", "presente", "futuro"]:
            socketio.emit('column_resource_update', {
                'room_id': room_id,
                'era': era,
                'columnTotals': column_totals[era]
            }, room=f"room_{room_id}")
        
        # Emitir evento global si corresponde
        if column in global_counters:
            socketio.emit('global_counter_update', {
                'globalTotals': global_counters
            })
        
        return jsonify({
            "success": True,
            "message": f"Contador de {column} reseteado correctamente"
        })
    except Exception as e:
        error_msg = f"Error al resetear columna: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/set_fluzo_value/<int:room_id>/<era>', methods=['POST'])
def set_fluzo_value(room_id, era):
    """Establece un valor especÃ­fico para el contador de fluzo"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        value = data.get('value', 0)
        silent = data.get('silent', False)  # Indicador para no mostrar notificaciÃ³n
        
        # Inicializar datos de la sala
        column_totals = GameData.initialize_room_column_totals(room_id)
        
        # Asegurarse de que fluzo existe en los datos de la columna
        if "fluzo" not in column_totals[era]:
            column_totals[era]["fluzo"] = 0
        
        # Establecer el valor directamente en lugar de incrementarlo
        column_totals[era]["fluzo"] = value
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        
        # Emitir evento de actualizaciÃ³n a la sala actual - no incluimos mensaje si es silencioso
        socketio.emit('fluzo_update', {
            'room_id': room_id,
            'era': era,
            'fluzoTotal': column_totals[era]["fluzo"],
            'fluzoValue': 0,  # La caja siempre muestra 0
            'isRandomValue': True,  # Indicar que este es un valor aleatorio
            'silent': silent  # Indicador para no mostrar notificaciÃ³n
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "fluzoTotal": column_totals[era]["fluzo"],
            "fluzoValue": 0  # Siempre devolver 0 para la caja
        })
    except Exception as e:
        error_msg = f"Error al establecer valor de fluzo: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/check_fluzo_value/<int:room_id>/<era>', methods=['POST'])
def check_fluzo_value(room_id, era):
    """Comprueba y actualiza el contador de fluzo, mostrando mensajes personalizados basados en el valor"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        total_value = data.get('total_value', 0)
        checked_value = data.get('checked_value', 0)
        custom_message = data.get('custom_message')  # Mensaje personalizado desde el cliente
        
        # Inicializar datos de la sala
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # Asegurarse de que fluzo existe en los datos de la columna
        if "fluzo" not in column_totals[era]:
            column_totals[era]["fluzo"] = 0
        
        # Establecer el nuevo valor total (puede ser un valor reducido)
        column_totals[era]["fluzo"] = max(0, total_value)  # Evitar valores negativos en el total
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        
        # Verificar si se ha completado "Consecuencias Imprevistas"
        all_have_81 = True
        consecuencias_completado = False
        
        # Inicializar la variable para "consecuencias_imprevistas" si no existe
        if "consecuencias_imprevistas" not in global_counters:
            global_counters["consecuencias_imprevistas"] = False
        
        # Recuperar el estado actual
        consecuencias_completado = global_counters["consecuencias_imprevistas"]
        
        # Si ya estÃ¡ completado, no necesitamos verificar de nuevo
        if not consecuencias_completado:
            # Verificar todas las salas
            for key in GameData._game_data.keys():
                if key.startswith("room_"):
                    room_id_check = int(key.split("_")[1])
                    room_data = GameData.initialize_room_column_totals(room_id_check)
                    
                    # Verificar cada era en esta sala
                    for check_era in ["pasado", "presente", "futuro"]:
                        if "fluzo" not in room_data[check_era] or room_data[check_era]["fluzo"] != 81:
                            all_have_81 = False
                            break
                    
                    if not all_have_81:
                        break
                            
            # Si todos tienen 81, marcar como completado y usar un mensaje especial
            if all_have_81:
                consecuencias_completado = True
                global_counters["consecuencias_imprevistas"] = True
                GameData.save_global_counters(global_counters)
                
                # Emitir evento especial para notificar a todos los clientes
                socketio.emit('consecuencias_imprevistas_completed', {
                    'message': "Se ha completado Consecuencias Imprevistas"
                })
                
                message = "Se ha completado Consecuencias Imprevistas"
            else:
                # Usar el mensaje personalizado del cliente si estÃ¡ disponible
                message = custom_message
                
                # Si no hay mensaje personalizado y estamos en Plan 1a. Primer avance (ciclo 2), generarlo basado en el valor
                if message is None and global_counters["perdicion_cycle"] == 2:
                    if column_totals[era]["fluzo"] < 78:
                        message = "El valor de fluzo condensado es inferior a la media"
                    elif column_totals[era]["fluzo"] > 78:
                        message = "El valor de fluzo condensado es superior a la media"
                    elif column_totals[era]["fluzo"] == 78:
                        message = "Â¡Estas en la media! No alteres mÃ¡s tu valor de fluzo condensado, trata de ayudar a otros grupos colocando pistas en la Reserva temporal"
                
                # Si no hay mensaje personalizado y estamos en Plan 1a. Segundo avance (ciclo 3), generarlo basado en el valor
                elif message is None and global_counters["perdicion_cycle"] == 3:
                    if column_totals[era]["fluzo"] < 81:
                        message = "El valor de fluzo condensado es inferior a la media"
                    elif column_totals[era]["fluzo"] > 81:
                        message = "El valor de fluzo condensado es superior a la media"
                    elif column_totals[era]["fluzo"] == 81:
                        message = "Â¡Estas en la media! No alteres mÃ¡s tu valor de fluzo condensado, trata de ayudar a otros grupos colocando pistas en la Reserva temporal"
        else:
            # Si ya estÃ¡ completado, mantener el mensaje especial
            message = "Se ha completado Consecuencias Imprevistas"
        
        # Emitir evento de actualizaciÃ³n a la sala actual
        socketio.emit('fluzo_update', {
            'room_id': room_id,
            'era': era,
            'fluzoTotal': column_totals[era]["fluzo"],
            'fluzoValue': 0,  # Resetear la caja a 0
            'checkedValue': checked_value,
            'message': message,
            'consecuenciasCompleted': consecuencias_completado
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "fluzoTotal": column_totals[era]["fluzo"],
            "message": message,
            "consecuenciasCompleted": consecuencias_completado
        })
    except Exception as e:
        error_msg = f"Error al comprobar fluzo: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

# FunciÃ³n auxiliar para desactivar botones dependientes
def deactivate_dependent_buttons(progress, dependency_key):
    """Desactiva recursivamente todos los botones que dependen de uno especÃ­fico"""
    for era in ["pasado", "presente", "futuro"]:
        for idx, deps in GameData.button_dependencies[era].items():
            if dependency_key in deps:
                # Este botÃ³n depende del que estamos desactivando, lo desactivamos tambiÃ©n
                if progress[era][idx]:
                    progress[era][idx] = False
                    # Y propagamos la desactivaciÃ³n recursivamente
                    deactivate_dependent_buttons(progress, f"{era}-{idx}")

# FunciÃ³n auxiliar para verificar quÃ© botones estÃ¡n disponibles
def get_available_buttons(progress):
    """Verifica quÃ© botones estÃ¡n disponibles segÃºn las dependencias actuales"""
    available_buttons = {
        "pasado": [],
        "presente": [],
        "futuro": []
    }
    
    for era in ["pasado", "presente", "futuro"]:
        for i in range(len(GameData.button_info[era])):
            is_available = True
            for dep in GameData.button_dependencies[era][i]:
                dep_era, dep_idx = dep.split('-')
                dep_idx = int(dep_idx)
                if not progress[dep_era][dep_idx]:
                    is_available = False
                    break
            available_buttons[era].append(is_available)
    
    return available_buttons

# Manejador para unirse a una sala (Socket.IO)
@socketio.on('join')
def on_join(data):
    """Maneja cuando un cliente se une a una sala especÃ­fica"""
    try:
        room = data.get('room')
        if room:
            join_room(room)
            print(f"Cliente unido a sala: {room}")
            
            # Si es un administrador, unirlo a la sala admin_room
            if 'is_admin' in session and session['is_admin']:
                join_room('admin_room')
                print(f"Administrador unido a sala admin_room")
    except Exception as e:
        print(f"Error al unir a sala: {str(e)}")
        traceback.print_exc()

# Manejador para abandonar una sala (Socket.IO)
@socketio.on('leave')
def on_leave(data):
    """Maneja cuando un cliente abandona una sala especÃ­fica"""
    try:
        room = data.get('room')
        if room:
            leave_room(room)
            print(f"Cliente abandonÃ³ la sala: {room}")
            
            # Si es un administrador, hacer que abandone la sala admin_room
            if 'is_admin' in session and session['is_admin']:
                leave_room('admin_room')
                print(f"Administrador abandonÃ³ la sala admin_room")
    except Exception as e:
        print(f"Error al abandonar sala: {str(e)}")
        traceback.print_exc()

# Manejador para la desconexiÃ³n de un cliente (Socket.IO)
@socketio.on('disconnect')
def handle_disconnect():
    """Maneja la desconexiÃ³n de un cliente"""
    try:
        print(f"Cliente desconectado")
        # No es necesario hacer nada aquÃ­, Flask-SocketIO maneja automÃ¡ticamente
        # el abandono de las salas cuando un cliente se desconecta
    except Exception as e:
        print(f"Error en desconexiÃ³n: {str(e)}")
        traceback.print_exc()


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\controllers\room_controller.py
--------------------------------------------------
from flask import Blueprint, render_template, redirect, url_for, session, flash, request, jsonify
from app.models.auth import Auth
from app.models.game_data import GameData
from app import socketio
from flask_socketio import emit, join_room, leave_room
import traceback

# Crear blueprint para rutas de sala y eras
room_bp = Blueprint('game', __name__)

# Nueva funciÃ³n para verificar si se cumplen las tres condiciones en todas las mesas
def check_victory_conditions():
    """Verifica si todas las mesas cumplen las tres condiciones de victoria"""
    try:
        # Obtener todas las salas con datos
        room_ids = []
        for key in GameData._game_data.keys():
            if key.startswith("room_"):
                room_id = int(key.split("_")[1])
                room_ids.append(room_id)
        
        if not room_ids:
            return False  # No hay salas para verificar
        
        # Verificar condiciones para cada sala
        for room_id in room_ids:
            room_data = GameData.initialize_room_data(room_id)
            column_totals = GameData.initialize_room_column_totals(room_id)
            
            # 1. Verificar si Biff ha sido derrotado en todas las eras
            for era in ["pasado", "presente", "futuro"]:
                if not room_data["biff_disabled"].get(era, False):
                    return False  # Biff no ha sido derrotado en todas las eras
            
            # 2. Verificar si todas las eras tienen fluzo = 81
            for era in ["pasado", "presente", "futuro"]:
                if "fluzo" not in column_totals[era] or column_totals[era]["fluzo"] != 81:
                    return False  # No todas las eras tienen fluzo = 81
            
            # 3. Verificar si "Un noble legado" estÃ¡ marcado en todas las eras
            # Identificar quÃ© Ã­ndice corresponde al anuncio de "Un noble legado" en cada era
            noble_legado_indices = {
                "pasado": 5,  # Ã­ndice 5 en la era pasado
                "presente": 4,  # Ã­ndice 4 en la era presente
                "futuro": 3    # Ã­ndice 3 en la era futuro
            }
            
            for era, idx in noble_legado_indices.items():
                if not room_data["progress"][era][idx]:
                    return False  # "Un noble legado" no estÃ¡ marcado en todas las eras
        
        # Si llegamos aquÃ­, todas las condiciones se cumplen en todas las salas
        return True
    
    except Exception as e:
        print(f"Error al verificar condiciones de victoria: {str(e)}")
        traceback.print_exc()
        return False

@room_bp.route('/room/<int:room_id>')
def room(room_id):
    """Vista de selecciÃ³n de eras en una sala"""
    # Solo los administradores pueden acceder a la vista de selecciÃ³n de eras
    if not ('is_admin' in session and session['is_admin']):
        flash('No tienes permiso para acceder a esta pÃ¡gina.', 'error')
        
        # Si el usuario tiene una era asignada, redirigirlo allÃ­
        if 'assigned_group' in session and 'assigned_era' in session:
            return redirect(url_for('game.era', room_id=session['assigned_group'], era=session['assigned_era']))
        else:
            return redirect(url_for('auth.index'))
    
    room = Auth.get_room_by_id(room_id)
    if not room:
        return redirect(url_for('auth.index'))
    
    return render_template('room.html', room=room, is_admin='is_admin' in session and session['is_admin'])
@room_bp.route('/era/<int:room_id>/<era>')
def era(room_id, era):
    """Vista de una era especÃ­fica en una sala"""
    # Verificar acceso
    if 'is_admin' in session and session['is_admin']:
        # Los admins pueden acceder a cualquier era de cualquier grupo
        pass
    elif 'assigned_group' in session and 'assigned_era' in session:
        # Verificar que el usuario solo pueda acceder a su grupo y era asignada
        if session['assigned_group'] != room_id or session['assigned_era'] != era:
            flash('No tienes permiso para acceder a este grupo o era.', 'error')
            return redirect(url_for('game.era', room_id=session['assigned_group'], era=session['assigned_era']))
    else:
        flash('No tienes permiso para acceder a esta pÃ¡gina.', 'error')
        return redirect(url_for('auth.index'))
    
    if era not in ["pasado", "presente", "futuro"]:
        if 'assigned_era' in session:
            return redirect(url_for('game.era', room_id=room_id, era=session['assigned_era']))
        else:
            return redirect(url_for('auth.index'))
    
    room = Auth.get_room_by_id(room_id)
    if not room:
        return redirect(url_for('auth.index'))
    
    # Inicializar o cargar datos de la sala
    room_data = GameData.initialize_room_data(room_id)
    progress = room_data["progress"]
    resources = room_data["resources"]
    biff_defeats = room_data["biff_defeats"]
    biff_disabled = room_data["biff_disabled"]  # AÃ±adir campo de desactivaciÃ³n de Biff
    
    # Verificar cuÃ¡les botones estÃ¡n disponibles segÃºn las dependencias
    available_buttons = []
    for i in range(len(GameData.button_info[era])):
        is_available = True
        for dep in GameData.button_dependencies[era][i]:
            dep_era, dep_idx = dep.split('-')
            dep_idx = int(dep_idx)
            if not progress[dep_era][dep_idx]:
                is_available = False
                break
        available_buttons.append(is_available)
    
    # Obtener el nombre de la mesa si aplica
    mesa_name = ""
    if 'mesa_code' in session:
        mesa_code = session['mesa_code']
        # Convertir mesa01 a Mesa 01
        mesa_name = "Mesa " + mesa_code[4:].zfill(2).upper()
    
    # Obtener el ciclo actual de perdiciÃ³n
    global_counters = GameData.initialize_global_counters()
    perdicion_cycle = global_counters["perdicion_cycle"]
    
    # Inicializar columnas de la sala
    column_totals = GameData.initialize_room_column_totals(room_id)
    
    # Verificar condiciones de victoria para R1
    victory_conditions_met = check_victory_conditions()
    
    # AÃ±adir al contexto de la plantilla
    return render_template('era.html', 
                          room=room, 
                          era=era, 
                          progress=progress,
                          button_info=GameData.button_info[era],
                          available_buttons=available_buttons,
                          resources=resources,
                          biff_defeats=biff_defeats[era],
                          biff_disabled=biff_disabled[era],
                          mesa_name=mesa_name,
                          perdicion_cycle=perdicion_cycle,
                          column_totals=column_totals[era],
                          victory_conditions_met=victory_conditions_met,
                          is_admin='is_admin' in session and session['is_admin'])
@room_bp.route('/toggle_button/<int:room_id>/<era>/<int:button_idx>', methods=['POST'])
def toggle_button(room_id, era, button_idx):
    """Activa o desactiva un botÃ³n de anuncio"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        flash('No tienes permiso para realizar esta acciÃ³n.', 'error')
        return redirect(url_for('auth.index'))
    
    if era not in ["pasado", "presente", "futuro"]:
        if 'assigned_era' in session:
            return redirect(url_for('game.era', room_id=room_id, era=session['assigned_era']))
        else:
            return redirect(url_for('auth.index'))
    
    try:
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Determinar si estamos activando o desactivando el botÃ³n
        is_activating = not room_data["progress"][era][button_idx]
        
        # Si es admin, permitir activar cualquier botÃ³n sin restricciones
        if 'is_admin' in session and session['is_admin']:
            # Si estamos desactivando, desactivar tambiÃ©n los dependientes
            if not is_activating:
                # Primero, cambiamos el estado del botÃ³n principal
                room_data["progress"][era][button_idx] = False
                
                # Luego desactivamos todos los que dependen de este
                deactivate_dependent_buttons(room_data["progress"], f"{era}-{button_idx}")
            else:
                # Si estamos activando, simplemente activamos este botÃ³n
                room_data["progress"][era][button_idx] = True
        else:
            # Verificar si se cumplen las dependencias para activar
            if is_activating:
                can_toggle = True
                for dep in GameData.button_dependencies[era][button_idx]:
                    dep_era, dep_idx = dep.split('-')
                    dep_idx = int(dep_idx)
                    if not room_data["progress"][dep_era][dep_idx]:
                        can_toggle = False
                        break
                
                if can_toggle:
                    # Cambiar el estado del botÃ³n (activar)
                    room_data["progress"][era][button_idx] = True
            else:
                # Si estÃ¡ desactivando, verificar y desactivar dependientes
                room_data["progress"][era][button_idx] = False
                deactivate_dependent_buttons(room_data["progress"], f"{era}-{button_idx}")
        
        # Verificar todos los botones en todas las eras para determinar las dependencias correctamente
        all_available_buttons = get_available_buttons(room_data["progress"])
        
        # Verificar si se han cumplido las condiciones de victoria despuÃ©s del cambio
        victory_conditions_met = check_victory_conditions()
        
        # Emitir evento de actualizaciÃ³n a todos los clientes en la sala
        socketio.emit('button_update', {
            'room_id': room_id,
            'era': era,
            'progress': room_data["progress"],
            'available_buttons': all_available_buttons,
            'button_idx': button_idx,  # Enviar quÃ© botÃ³n especÃ­fico se ha cambiado
            'is_activating': is_activating  # Indicar si se estÃ¡ activando o desactivando
        }, room=f"room_{room_id}")
        
        # Si se cumplen las condiciones de victoria, emitir evento especial
        if victory_conditions_met:
            socketio.emit('victory_conditions_met', {
                'message': "->R1"
            })
        
        # Determinar si la solicitud fue AJAX o normal
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({
                'success': True,
                'message': 'BotÃ³n actualizado correctamente',
                'progress': room_data["progress"],
                'available_buttons': all_available_buttons,
                'victory_conditions_met': victory_conditions_met
            })
        else:
            return redirect(url_for('game.era', room_id=room_id, era=era))
    except Exception as e:
        error_msg = f"Error al actualizar botÃ³n: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        
        if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
            return jsonify({
                'success': False,
                'error': error_msg
            })
        else:
            flash(error_msg, 'error')
            return redirect(url_for('game.era', room_id=room_id, era=era))
@room_bp.route('/update_resources/<int:room_id>/<era>', methods=['POST'])
def update_resources(room_id, era):
    """Actualiza los recursos de una era"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos de recursos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        resource_amount = data.get('amount', 0)
        
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Actualizar los recursos
        room_data["resources"][era] += resource_amount
        room_data["resources"]["total"] += resource_amount
        
        # Emitir evento de actualizaciÃ³n de recursos a todos los clientes en la sala
        socketio.emit('resource_update', {
            'room_id': room_id,
            'resources': room_data["resources"]
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "resources": room_data["resources"]
        })
    except Exception as e:
        error_msg = f"Error al actualizar recursos: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

# FunciÃ³n interna para ajustar todos los valores de fluzo
def adjust_all_fluzo_values_internal():
    """Ajusta los valores de fluzo en todas las salas segÃºn las reglas especificadas (funciÃ³n interna)"""
    try:
        # Obtener todas las salas con datos
        room_ids = []
        for key in GameData._game_data.keys():
            if key.startswith("room_"):
                room_id = int(key.split("_")[1])
                room_ids.append(room_id)
        
        # Para cada sala, ajustar los valores de fluzo en todas las eras
        for room_id in room_ids:
            for era in ["pasado", "presente", "futuro"]:
                # Obtener los datos de la sala
                column_totals = GameData.initialize_room_column_totals(room_id)
                
                # Asegurarse de que fluzo existe en los datos
                if "fluzo" not in column_totals[era]:
                    column_totals[era]["fluzo"] = 0
                
                # Obtener el valor actual
                current_fluzo = column_totals[era]["fluzo"]
                new_fluzo = current_fluzo
                
                # Aplicar las reglas de ajuste:
                if current_fluzo > 86:
                    new_fluzo = current_fluzo - 10
                elif current_fluzo < 76:
                    new_fluzo = current_fluzo + 10
                elif current_fluzo >= 80 and current_fluzo <= 82:
                    new_fluzo = current_fluzo - 5
                
                # Solo actualizar si el valor ha cambiado
                if new_fluzo != current_fluzo:
                    # Actualizar el valor en la sala
                    column_totals[era]["fluzo"] = new_fluzo
                    
                    # Guardar los cambios
                    GameData.save_column_totals(room_id, column_totals)
                    
                    # Emitir evento de actualizaciÃ³n
                    socketio.emit('fluzo_update', {
                        'room_id': room_id,
                        'era': era,
                        'fluzoTotal': new_fluzo,
                        'fluzoValue': 0,  # La caja siempre muestra 0
                    }, room=f"room_{room_id}")
        
        # Verificar si se cumplen las condiciones de victoria despuÃ©s de ajustar
        victory_conditions_met = check_victory_conditions()
        if victory_conditions_met:
            socketio.emit('victory_conditions_met', {
                'message': "->R1"
            })
            
        return True
    except Exception as e:
        print(f"Error al ajustar valores de fluzo internamente: {str(e)}")
        traceback.print_exc()
        return False
@room_bp.route('/adjust_all_fluzo_values', methods=['POST'])
def adjust_all_fluzo_values():
    """Ajusta los valores de fluzo en todas las salas segÃºn las reglas especificadas"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    try:
        success = adjust_all_fluzo_values_internal()
        
        if success:
            # Verificar si se cumplen las condiciones de victoria despuÃ©s del ajuste
            victory_conditions_met = check_victory_conditions()
            
            return jsonify({
                "success": True,
                "message": "Valores de fluzo ajustados en todas las salas",
                "victory_conditions_met": victory_conditions_met
            })
        else:
            return jsonify({
                "success": False,
                "error": "Error al ajustar los valores de fluzo"
            })
    except Exception as e:
        error_msg = f"Error al ajustar valores de fluzo: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/biff_defeat/<int:room_id>/<era>', methods=['POST'])
def biff_defeat(room_id, era):
    """Incrementa el contador de derrotas de Biff"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Obtener el ciclo actual de perdiciÃ³n
        global_counters = GameData.initialize_global_counters()
        current_cycle = global_counters["perdicion_cycle"]
        is_plan_1a = (current_cycle == 1)
        
        # Si el botÃ³n ya estÃ¡ desactivado, no hacer nada
        if room_data["biff_disabled"][era]:
            return jsonify({
                "success": True,
                "defeats": room_data["biff_defeats"][era],
                "disable_button": True,
                "message": "Biff Tannen ya ha sido aÃ±adido a la zona de victoria."
            })
        
        # Obtener el nÃºmero actual de derrotas y sumamos 1 para obtener la nueva cantidad
        current_defeats = room_data["biff_defeats"][era]
        new_defeats = current_defeats + 1
        
        # Determinar el mensaje segÃºn el nÃºmero de derrotas
        biff_message = ""
        # Variable para indicar si se debe desactivar el botÃ³n
        disable_button = False
        
        if new_defeats == 1:
            biff_message = "\"Â¡Hey, McFly!\" Biff Tannen aparece agotado. Si en la partida esta Marty McFly, aparece en el Lugar de Marty, ignorando sus instrucciones de ApariciÃ³n"
        elif new_defeats == 2:
            biff_message = "\"Â¿Te estoy haciendo perder el tiempo?\": en lugar de derrotar a Biff Tannen, agÃ³talo. No se considera que haya sido derrotado."
        elif new_defeats == 3:
            biff_message = "\"Â¿Te estoy despistando?\": cada investigador debe colocar una de sus pistas sobre su Lugar, o bien recibir 1 punto de horror."
        elif new_defeats == 4:
            biff_message = "\"Â¡Llevo mucho tiempo preparando esto!\": Decides seguir el rastro que ha dejado Biff durante sus viajes en el tiempo. Coloca 1 pista (de la reserva de fichas) sobre cada Lugar en juego."
        elif new_defeats >= 5:
            # A partir de la quinta derrota (incluida)
            if not is_plan_1a:
                # Si NO estamos en Plan 1a, siempre mostrar este mensaje
                biff_message = "Dale la vuelta a Biff Tannen y aÃ±adelo a la zona de victoria."
                # Indicar que se debe desactivar el botÃ³n
                disable_button = True
                # Guardar el estado de desactivaciÃ³n
                room_data["biff_disabled"][era] = True
            else:
                # Si estamos en Plan 1a, depende del nÃºmero exacto de derrotas
                if new_defeats == 5:
                    biff_message = "\"Deja de golpearte, deja de golpearte, deja de golpearte\": Realiza una prueba de <span style=\"font-family: 'AHLCG';\">S</span>(2). Por cada punto que falte para tener Ã©xito, recibe 1 punto de daÃ±o."
                elif new_defeats == 6:
                    biff_message = "\"Â¡Tenemos tiempo de sobra!\": aÃ±ade 1 ficha de PerdiciÃ³n al Plan en curso."
                elif new_defeats == 7:
                    biff_message = "\"Â¡Ya no vas a necesitar esto!\": El investigador que ha derrotado a Biff descarta 1 Apoyo que controle, a ser posible un Apoyo usado para derrotar a Biff Tannen."
                else:  # 8 o mÃ¡s derrotas
                    # Seleccionar mensaje aleatorio entre los 3 disponibles
                    import random
                    random_messages = [
                        "\"Deja de golpearte, deja de golpearte, deja de golpearte\": Realiza una prueba de <span style=\"font-family: 'AHLCG';\">S</span>(2). Por cada punto que falte para tener Ã©xito, recibe 1 punto de daÃ±o.",
                        "\"Â¡Tenemos tiempo de sobra!\": aÃ±ade 1 ficha de PerdiciÃ³n al Plan en curso.",
                        "\"Â¡Ya no vas a necesitar esto!\": El investigador que ha derrotado a Biff descarta 1 Apoyo que controle, a ser posible un Apoyo usado para derrotar a Biff Tannen."
                    ]
                    biff_message = random.choice(random_messages)
        
        # Incrementar el contador de derrotas de Biff (sin lÃ­mite)
        room_data["biff_defeats"][era] += 1
        
        # Verificar si se cumplen las condiciones de victoria despuÃ©s del cambio
        victory_conditions_met = check_victory_conditions() if disable_button else False
        
        # Emitir evento de actualizaciÃ³n a todos los clientes en la sala
        socketio.emit('biff_update', {
            'room_id': room_id,
            'era': era,
            'defeats': room_data["biff_defeats"][era],
            'message': biff_message,  # AÃ±adir el mensaje a la respuesta
            'disable_button': disable_button  # Indicar si se debe desactivar el botÃ³n
        }, room=f"room_{room_id}")
        
        # Si se cumplen las condiciones de victoria, emitir evento especial
        if victory_conditions_met:
            socketio.emit('victory_conditions_met', {
                'message': "->R1"
            })
        
        return jsonify({
            "success": True,
            "defeats": room_data["biff_defeats"][era],
            "message": biff_message,  # AÃ±adir el mensaje a la respuesta
            "disable_button": disable_button,  # Indicar si se debe desactivar el botÃ³n
            "victory_conditions_met": victory_conditions_met
        })
    except Exception as e:
        error_msg = f"Error al actualizar derrotas de Biff: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})
@room_bp.route('/update_column_resource/<int:room_id>/<era>/<column>', methods=['POST'])
def update_column_resource(room_id, era, column):
    """Actualiza un contador de columna especÃ­fico"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    if column not in ["perdicion", "reserva", "fluzo"]:  # AÃ±adido fluzo a las columnas permitidas
        return jsonify({"success": False, "error": "Columna invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        amount = data.get('amount', 0)
        
        # Inicializar datos de la sala y contadores
        room_data = GameData.initialize_room_data(room_id)
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # MODIFICACIÃ“N: LÃ³gica para valores negativos en PerdiciÃ³n
        if column == "perdicion" and amount < 0:
            # Verificar que el valor global no se vuelva negativo
            new_global_value = global_counters["perdicion"] + amount
            
            if new_global_value < 0:
                # Limitar la reducciÃ³n para que el total sea 0
                amount = -global_counters["perdicion"]
                new_global_value = 0
        
        # Variable para controlar si estamos completando un ciclo
        cycle_completed = False
        notification = None
        
        # LÃ³gica especial para perdiciÃ³n
        if column == "perdicion":
            # Si estamos en el ciclo 3 y ya ha terminado, no permitimos mÃ¡s cambios
            if global_counters["perdicion_cycle"] > 3:
                return jsonify({
                    "success": False,
                    "error": "El contador de perdiciÃ³n ha completado todos sus ciclos."
                })
            
            # Calculamos el nuevo valor despuÃ©s del cambio
            new_perdicion_value = global_counters["perdicion"] + amount
            
            # Verificar que el nuevo valor no sea negativo
            if new_perdicion_value < 0:
                new_perdicion_value = 0
                # Ajustar la cantidad para que el contador de la sala tambiÃ©n se actualice correctamente
                amount = -global_counters["perdicion"]
                
            # Verificar lÃ­mites segÃºn el ciclo actual
            cycle_limits = {1: 5, 2: 4, 3: 5}
            current_cycle = global_counters["perdicion_cycle"]
            
            # Si alcanzamos o superamos el lÃ­mite del ciclo actual
            if current_cycle in cycle_limits and new_perdicion_value >= cycle_limits[current_cycle]:
                # Enviamos una notificaciÃ³n segÃºn el ciclo
                notifications = {
                    1: "Haz avanzar al Plan 1b",
                    2: "Haz avanzar al Plan 1b. El valor de Fluzo ha sido alterado",
                    3: "(->R2)"
                }
                notification = notifications[current_cycle]
                
                # Actualizamos el ciclo y reseteamos el contador global
                global_counters["perdicion_cycle"] += 1
                global_counters["perdicion"] = 0
                
                # Marcamos que se completÃ³ un ciclo
                cycle_completed = True
                
                # Reiniciamos los contadores de perdiciÃ³n para todas las salas
                # 1. Reiniciamos los contadores de la sala actual
                for reset_era in ["pasado", "presente", "futuro"]:
                    column_totals[reset_era]["perdicion"] = 0
                
                # 2. Guardar en la sala actual
                GameData.save_column_totals(room_id, column_totals)
                
                # 3. Reiniciar contadores de perdiciÃ³n en TODAS las salas
                GameData.reset_perdicion_all_rooms()
                
                # 4. Si estamos pasando del ciclo 2 al ciclo 3, ajustar valores de fluzo
                if current_cycle == 2:
                    # Llamar a la funciÃ³n para ajustar todos los valores de fluzo
                    adjust_all_fluzo_values_internal()
            else:
                # Si no alcanzamos el lÃ­mite, actualizamos normalmente
                global_counters["perdicion"] = new_perdicion_value
                column_totals[era][column] += amount
        elif column == "fluzo":
            # Para fluzo, simplemente actualizamos el valor en la sala
            column_totals[era][column] += amount
            
            # Verificar si se cumplen las condiciones de victoria despuÃ©s del cambio
            victory_conditions_met = check_victory_conditions()
            
            # Si se cumplen las condiciones de victoria, emitir evento especial
            if victory_conditions_met:
                socketio.emit('victory_conditions_met', {
                    'message': "->R1"
                })
        else:
            # Para otros contadores (reserva) actualizamos normalmente
            # TambiÃ©n evitamos valores negativos para la reserva global
            new_value = global_counters[column] + amount
            if new_value < 0:
                new_value = 0
                # Ajustar la cantidad para que el contador de la sala tambiÃ©n se actualice correctamente
                amount = -global_counters[column]
            
            global_counters[column] = new_value
            
            # TambiÃ©n evitamos valores negativos para el contador de la sala
            new_room_value = column_totals[era][column] + amount
            if new_room_value < 0:
                new_room_value = 0
                amount = -column_totals[era][column]
            
            column_totals[era][column] = new_room_value
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        GameData.save_global_counters(global_counters)
        
        # Emitir eventos segÃºn corresponda
        if cycle_completed:
            # Si se completÃ³ un ciclo, enviar un evento a TODAS las mesas en TODAS las salas
            # Este evento forzarÃ¡ la actualizaciÃ³n de todos los contadores de perdiciÃ³n
            socketio.emit('perdicion_cycle_completed', {
                'perdicionCycle': global_counters["perdicion_cycle"],
                'notification': notification,
                'originRoom': room_id,
                'originEra': era
            })
        else:
            # Comportamiento normal - enviar solo para la era actual
            socketio.emit('column_resource_update', {
                'room_id': room_id,
                'era': era,
                'columnTotals': column_totals[era],
                'notification': notification,
                'perdicionCycle': global_counters["perdicion_cycle"]
            }, room=f"room_{room_id}")
        
        # Emitir evento global a todos los clientes conectados
        socketio.emit('global_counter_update', {
            'globalTotals': global_counters,
            'notification': notification,
            'cycleCompleted': cycle_completed
        })
        
        # Verificar si se cumplen las condiciones de victoria
        victory_conditions_met = check_victory_conditions()
        if victory_conditions_met:
            socketio.emit('victory_conditions_met', {
                'message': "->R1"
            })
        
        return jsonify({
            "success": True,
            "columnTotals": column_totals[era],
            "globalTotals": global_counters,
            "notification": notification,
            "victory_conditions_met": victory_conditions_met
        })
    except Exception as e:
        error_msg = f"Error al actualizar columna: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})
# Controlador para PerdiciÃ³n
@room_bp.route('/update_perdicion/<int:room_id>/<era>', methods=['POST'])
def update_perdicion(room_id, era):
    """Actualiza especÃ­ficamente el contador de perdiciÃ³n"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        amount = data.get('amount', 0)
        
        # Inicializar datos de la sala y contadores
        room_data = GameData.initialize_room_data(room_id)
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # LÃ³gica para valores negativos en PerdiciÃ³n
        if amount < 0:
            # Verificar que el valor global no se vuelva negativo
            new_global_value = global_counters["perdicion"] + amount
            
            if new_global_value < 0:
                # Limitar la reducciÃ³n para que el total sea 0
                amount = -global_counters["perdicion"]
                new_global_value = 0
        
        # Variable para controlar si estamos completando un ciclo
        cycle_completed = False
        notification = None
        
        # Si estamos en el ciclo 3 y ya ha terminado, no permitimos mÃ¡s cambios
        if global_counters["perdicion_cycle"] > 3:
            return jsonify({
                "success": False,
                "error": "El contador de perdiciÃ³n ha completado todos sus ciclos."
            })
        
        # Calculamos el nuevo valor despuÃ©s del cambio
        new_perdicion_value = global_counters["perdicion"] + amount
        
        # Verificar que el nuevo valor no sea negativo
        if new_perdicion_value < 0:
            new_perdicion_value = 0
            # Ajustar la cantidad para que el contador de la sala tambiÃ©n se actualice correctamente
            amount = -global_counters["perdicion"]
            
        # Verificar lÃ­mites segÃºn el ciclo actual
        cycle_limits = {1: 5, 2: 4, 3: 5}
        current_cycle = global_counters["perdicion_cycle"]
        
        # Si alcanzamos o superamos el lÃ­mite del ciclo actual
        if current_cycle in cycle_limits and new_perdicion_value >= cycle_limits[current_cycle]:
            # Enviamos una notificaciÃ³n segÃºn el ciclo
            notifications = {
                1: "Haz avanzar al Plan 1b",
                2: "Haz avanzar al Plan 1b. El valor de Fluzo ha sido alterado",
                3: "(->R4)"
            }
            notification = notifications[current_cycle]
            
            # Actualizamos el ciclo y reseteamos el contador global
            global_counters["perdicion_cycle"] += 1
            global_counters["perdicion"] = 0
            
            # Marcamos que se completÃ³ un ciclo
            cycle_completed = True
            
            # Reiniciamos los contadores de perdiciÃ³n para todas las salas
            # 1. Reiniciamos los contadores de la sala actual
            for reset_era in ["pasado", "presente", "futuro"]:
                column_totals[reset_era]["perdicion"] = 0
            
            # 2. Guardar en la sala actual
            GameData.save_column_totals(room_id, column_totals)
            
            # 3. Reiniciar contadores de perdiciÃ³n en TODAS las salas
            GameData.reset_perdicion_all_rooms()
            
            # 4. Si estamos pasando del ciclo 2 al ciclo 3, ajustar valores de fluzo
            if current_cycle == 2:
                # Llamar a la funciÃ³n para ajustar todos los valores de fluzo
                adjust_all_fluzo_values_internal()
        else:
            # Si no alcanzamos el lÃ­mite, actualizamos normalmente
            global_counters["perdicion"] = new_perdicion_value
            column_totals[era]["perdicion"] += amount
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        GameData.save_global_counters(global_counters)
        
        # Emitir eventos segÃºn corresponda
        if cycle_completed:
            # Si se completÃ³ un ciclo, enviar un evento a TODAS las mesas en TODAS las salas
            socketio.emit('perdicion_cycle_completed', {
                'perdicionCycle': global_counters["perdicion_cycle"],
                'notification': notification,
                'originRoom': room_id,
                'originEra': era
            })
        else:
            # Comportamiento normal - enviar solo para la era actual
            socketio.emit('perdicion_update', {
                'room_id': room_id,
                'era': era,
                'columnTotal': column_totals[era]["perdicion"],
                'notification': notification,
                'perdicionCycle': global_counters["perdicion_cycle"]
            }, room=f"room_{room_id}")
        
        # Emitir evento global a todos los clientes conectados
        socketio.emit('global_perdicion_update', {
            'globalTotal': global_counters["perdicion"],
            'perdicionCycle': global_counters["perdicion_cycle"],
            'notification': notification,
            'cycleCompleted': cycle_completed
        })
        
        # Verificar si se cumplen las condiciones de victoria
        victory_conditions_met = check_victory_conditions()
        if victory_conditions_met:
            socketio.emit('victory_conditions_met', {
                'message': "->R1"
            })
        
        return jsonify({
            "success": True,
            "columnTotal": column_totals[era]["perdicion"],
            "globalTotal": global_counters["perdicion"],
            "perdicionCycle": global_counters["perdicion_cycle"],
            "notification": notification,
            "victory_conditions_met": victory_conditions_met
        })
    except Exception as e:
        error_msg = f"Error al actualizar perdiciÃ³n: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})
# Controlador para Reserva
@room_bp.route('/update_reserva/<int:room_id>/<era>', methods=['POST'])
def update_reserva(room_id, era):
    """Actualiza especÃ­ficamente el contador de reserva"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        amount = data.get('amount', 0)
        
        # Inicializar datos de la sala y contadores
        room_data = GameData.initialize_room_data(room_id)
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # MODIFICACIÃ“N: LÃ³gica para valores negativos en Reserva
        if amount < 0:
            # Verificar que el valor global no se vuelva negativo
            new_global_value = global_counters["reserva"] + amount
            
            if new_global_value < 0:
                # Limitar la reducciÃ³n para que el total sea 0
                amount = -global_counters["reserva"]
                new_global_value = 0
            
            global_counters["reserva"] = new_global_value
        else:
            # Si es un valor positivo, simplemente sumarlo
            global_counters["reserva"] += amount
        
        # IMPORTANTE: Permitir valores negativos en el contador de la sala
        # Actualizar el valor de la sala directamente sin forzar que sea positivo
        column_totals[era]["reserva"] += amount
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        GameData.save_global_counters(global_counters)
        
        # Emitir evento de actualizaciÃ³n a la sala actual
        socketio.emit('reserva_update', {
            'room_id': room_id,
            'era': era,
            'columnTotal': column_totals[era]["reserva"]
        }, room=f"room_{room_id}")
        
        # Emitir evento global a todos los clientes conectados
        socketio.emit('global_reserva_update', {
            'globalTotal': global_counters["reserva"]
        })
        
        return jsonify({
            "success": True,
            "columnTotal": column_totals[era]["reserva"],
            "globalTotal": global_counters["reserva"]
        })
    except Exception as e:
        error_msg = f"Error al actualizar reserva: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

# Controlador para Fluzo
@room_bp.route('/update_fluzo/<int:room_id>/<era>', methods=['POST'])
def update_fluzo(room_id, era):
    """Actualiza especÃ­ficamente el contador de fluzo"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        amount = data.get('amount', 0)
        
        # Inicializar datos de la sala
        column_totals = GameData.initialize_room_column_totals(room_id)
        
        # Asegurarse de que fluzo existe en los datos de la columna
        if "fluzo" not in column_totals[era]:
            column_totals[era]["fluzo"] = 0
        
        # Actualizar valor de fluzo en la sala
        column_totals[era]["fluzo"] += amount
        
        # Si el valor se vuelve negativo, establecerlo a 0
        if column_totals[era]["fluzo"] < 0:
            column_totals[era]["fluzo"] = 0
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        
        # Verificar si se cumplen las condiciones de victoria
        victory_conditions_met = check_victory_conditions()
        
        # Emitir evento de actualizaciÃ³n a la sala actual
        socketio.emit('fluzo_update', {
            'room_id': room_id,
            'era': era,
            'fluzoTotal': column_totals[era]["fluzo"],
            'fluzoValue': 0,  # La caja siempre muestra 0
            'isRandomValue': True  # Indicar que este es un valor aleatorio
        }, room=f"room_{room_id}")
        
        # Si se cumplen las condiciones de victoria, emitir evento especial
        if victory_conditions_met:
            socketio.emit('victory_conditions_met', {
                'message': "->R1"
            })

        return jsonify({
            "success": True,
            "fluzoTotal": column_totals[era]["fluzo"],
            "fluzoValue": 0,  # Siempre devolver 0 para la caja
            "victory_conditions_met": victory_conditions_met
        })
    except Exception as e:
        error_msg = f"Error al actualizar fluzo: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})
@room_bp.route('/get_column_totals/<int:room_id>/<era>', methods=['GET'])
def get_column_totals(room_id, era):
    """Obtiene los totales de columna para una era especÃ­fica"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Inicializar datos de la sala y contadores
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # Verificar condiciones de victoria
        victory_conditions_met = check_victory_conditions()
        
        return jsonify({
            "success": True,
            "columnTotals": column_totals[era],
            "globalTotals": global_counters,
            "victory_conditions_met": victory_conditions_met
        })
    except Exception as e:
        error_msg = f"Error al obtener totales de columna: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/get_global_counters', methods=['GET'])
def get_global_counters():
    """Obtiene los contadores globales"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and 'assigned_group' not in session:
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    try:
        # Inicializar contadores globales
        global_counters = GameData.initialize_global_counters()
        
        # Asegurar que consecuencias_imprevistas existe en los contadores
        if "consecuencias_imprevistas" not in global_counters:
            global_counters["consecuencias_imprevistas"] = False
            GameData.save_global_counters(global_counters)
        
        # Verificar condiciones de victoria
        victory_conditions_met = check_victory_conditions()
        
        return jsonify({
            "success": True,
            "globalTotals": global_counters,
            "victory_conditions_met": victory_conditions_met
        })
    except Exception as e:
        error_msg = f"Error al obtener contadores globales: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/reset_announcements/<int:room_id>/<era>', methods=['POST'])
def reset_announcements(room_id, era):
    """Resetea todos los anuncios de una era especÃ­fica"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Resetear todos los anuncios de esta era
        for i in range(len(room_data["progress"][era])):
            room_data["progress"][era][i] = False
        
        # Verificar todos los botones para actualizar las dependencias
        all_available_buttons = get_available_buttons(room_data["progress"])
        
        # Emitir evento de actualizaciÃ³n a todos los clientes en la sala
        socketio.emit('button_update', {
            'room_id': room_id,
            'era': era,
            'progress': room_data["progress"],
            'available_buttons': all_available_buttons
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "message": "Anuncios reseteados correctamente"
        })
    except Exception as e:
        error_msg = f"Error al resetear anuncios: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})
@room_bp.route('/reset_biff/<int:room_id>/<era>', methods=['POST'])
def reset_biff(room_id, era):
    """Resetea el contador de derrotas de Biff para una era especÃ­fica"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Inicializar o cargar datos de la sala
        room_data = GameData.initialize_room_data(room_id)
        
        # Resetear el contador de Biff
        room_data["biff_defeats"][era] = 0
        
        # Resetear tambiÃ©n el estado de desactivaciÃ³n
        room_data["biff_disabled"][era] = False
        
        # Emitir evento de actualizaciÃ³n a todos los clientes en la sala
        socketio.emit('biff_update', {
            'room_id': room_id,
            'era': era,
            'defeats': 0,
            'disable_button': False
        }, room=f"room_{room_id}")
        
        return jsonify({
            "success": True,
            "message": "Contador de Biff reseteado correctamente"
        })
    except Exception as e:
        error_msg = f"Error al resetear contador de Biff: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/reset_column/<int:room_id>/<column>', methods=['POST'])
def reset_column(room_id, column):
    """Resetea un contador de columna especÃ­fico en todas las eras"""
    # Verificar que sea un admin
    if not ('is_admin' in session and session['is_admin']):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if column not in ["perdicion", "reserva"]:
        return jsonify({"success": False, "error": "Columna invÃ¡lida"})
    
    try:
        # Inicializar datos de la sala
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # Resetear la columna en todas las eras
        for era in ["pasado", "presente", "futuro"]:
            column_totals[era][column] = 0
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        
        # Resetear tambiÃ©n el contador global si corresponde
        if column in global_counters:
            global_counters[column] = 0
            GameData.save_global_counters(global_counters)
        
        # Emitir eventos de actualizaciÃ³n a todos los clientes en la sala
        for era in ["pasado", "presente", "futuro"]:
            socketio.emit('column_resource_update', {
                'room_id': room_id,
                'era': era,
                'columnTotals': column_totals[era]
            }, room=f"room_{room_id}")
        
        # Emitir evento global si corresponde
        if column in global_counters:
            socketio.emit('global_counter_update', {
                'globalTotals': global_counters
            })
        
        return jsonify({
            "success": True,
            "message": f"Contador de {column} reseteado correctamente"
        })
    except Exception as e:
        error_msg = f"Error al resetear columna: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})
@room_bp.route('/set_fluzo_value/<int:room_id>/<era>', methods=['POST'])
def set_fluzo_value(room_id, era):
    """Establece un valor especÃ­fico para el contador de fluzo"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        value = data.get('value', 0)
        silent = data.get('silent', False)  # Indicador para no mostrar notificaciÃ³n
        
        # Inicializar datos de la sala
        column_totals = GameData.initialize_room_column_totals(room_id)
        
        # Asegurarse de que fluzo existe en los datos de la columna
        if "fluzo" not in column_totals[era]:
            column_totals[era]["fluzo"] = 0
        
        # Establecer el valor directamente en lugar de incrementarlo
        column_totals[era]["fluzo"] = value
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        
        # Verificar si se cumplen las condiciones de victoria
        victory_conditions_met = check_victory_conditions()
        
        # Emitir evento de actualizaciÃ³n a la sala actual - no incluimos mensaje si es silencioso
        socketio.emit('fluzo_update', {
            'room_id': room_id,
            'era': era,
            'fluzoTotal': column_totals[era]["fluzo"],
            'fluzoValue': 0,  # La caja siempre muestra 0
            'isRandomValue': True,  # Indicar que este es un valor aleatorio
            'silent': silent  # Indicador para no mostrar notificaciÃ³n
        }, room=f"room_{room_id}")
        
        # Si se cumplen las condiciones de victoria, emitir evento especial
        if victory_conditions_met:
            socketio.emit('victory_conditions_met', {
                'message': "->R1"
            })
        
        return jsonify({
            "success": True,
            "fluzoTotal": column_totals[era]["fluzo"],
            "fluzoValue": 0,  # Siempre devolver 0 para la caja
            "victory_conditions_met": victory_conditions_met
        })
    except Exception as e:
        error_msg = f"Error al establecer valor de fluzo: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})

@room_bp.route('/check_fluzo_value/<int:room_id>/<era>', methods=['POST'])
def check_fluzo_value(room_id, era):
    """Comprueba y actualiza el contador de fluzo, mostrando mensajes personalizados basados en el valor"""
    # Verificar acceso
    if not ('is_admin' in session and session['is_admin']) and ('assigned_group' not in session or session['assigned_group'] != room_id):
        return jsonify({"success": False, "error": "No tienes permiso para realizar esta acciÃ³n."})
    
    if era not in ["pasado", "presente", "futuro"]:
        return jsonify({"success": False, "error": "Era invÃ¡lida"})
    
    try:
        # Obtener datos del POST
        data = request.get_json()
        if data is None:
            return jsonify({"success": False, "error": "Datos no proporcionados o formato incorrecto"})
            
        total_value = data.get('total_value', 0)
        checked_value = data.get('checked_value', 0)
        custom_message = data.get('custom_message')  # Mensaje personalizado desde el cliente
        
        # Inicializar datos de la sala
        column_totals = GameData.initialize_room_column_totals(room_id)
        global_counters = GameData.initialize_global_counters()
        
        # Asegurarse de que fluzo existe en los datos de la columna
        if "fluzo" not in column_totals[era]:
            column_totals[era]["fluzo"] = 0
        
        # Establecer el nuevo valor total (puede ser un valor reducido)
        column_totals[era]["fluzo"] = max(0, total_value)  # Evitar valores negativos en el total
        
        # Guardar los cambios
        GameData.save_column_totals(room_id, column_totals)
        
        # Verificar si se ha completado "Consecuencias Imprevistas"
        all_have_81 = True
        consecuencias_completado = False
        
        # Inicializar la variable para "consecuencias_imprevistas" si no existe
        if "consecuencias_imprevistas" not in global_counters:
            global_counters["consecuencias_imprevistas"] = False
        
        # Recuperar el estado actual
        consecuencias_completado = global_counters["consecuencias_imprevistas"]
        
        # Si ya estÃ¡ completado, no necesitamos verificar de nuevo
        if not consecuencias_completado:
            # Verificar todas las salas
            for key in GameData._game_data.keys():
                if key.startswith("room_"):
                    room_id_check = int(key.split("_")[1])
                    room_data = GameData.initialize_room_column_totals(room_id_check)
                    
                    # Verificar cada era en esta sala
                    for check_era in ["pasado", "presente", "futuro"]:
                        if "fluzo" not in room_data[check_era] or room_data[check_era]["fluzo"] != 81:
                            all_have_81 = False
                            break
                    
                    if not all_have_81:
                        break
                            
            # Si todos tienen 81, marcar como completado y usar un mensaje especial
            if all_have_81:
                consecuencias_completado = True
                global_counters["consecuencias_imprevistas"] = True
                GameData.save_global_counters(global_counters)
                
                # Emitir evento especial para notificar a todos los clientes
                socketio.emit('consecuencias_imprevistas_completed', {
                    'message': "Se ha completado Consecuencias Imprevistas"
                })
                
                message = "Se ha completado Consecuencias Imprevistas"
            else:
                # Usar el mensaje personalizado del cliente si estÃ¡ disponible
                message = custom_message
                
                # Si no hay mensaje personalizado y estamos en Plan 1a. Primer avance (ciclo 2), generarlo basado en el valor
                if message is None and global_counters["perdicion_cycle"] == 2:
                    if column_totals[era]["fluzo"] < 78:
                        message = "El valor de fluzo condensado es inferior a la media"
                    elif column_totals[era]["fluzo"] > 78:
                        message = "El valor de fluzo condensado es superior a la media"
                    elif column_totals[era]["fluzo"] == 78:
                        message = "Â¡Estas en la media! No alteres mÃ¡s tu valor de fluzo condensado, trata de ayudar a otros grupos colocando pistas en la Reserva temporal"
                
                # Si no hay mensaje personalizado y estamos en Plan 1a. Segundo avance (ciclo 3), generarlo basado en el valor
                elif message is None and global_counters["perdicion_cycle"] == 3:
                    if column_totals[era]["fluzo"] < 81:
                        message = "El valor de fluzo condensado es inferior a la media"
                    elif column_totals[era]["fluzo"] > 81:
                        message = "El valor de fluzo condensado es superior a la media"
                    elif column_totals[era]["fluzo"] == 81:
                        message = "Â¡Estas en la media! No alteres mÃ¡s tu valor de fluzo condensado, trata de ayudar a otros grupos colocando pistas en la Reserva temporal"
        else:
            # Si ya estÃ¡ completado, mantener el mensaje especial
            message = "Se ha completado Consecuencias Imprevistas"
        
        # Verificar si se cumplen las condiciones de victoria
        victory_conditions_met = check_victory_conditions()
        
        # Emitir evento de actualizaciÃ³n a la sala actual
        socketio.emit('fluzo_update', {
            'room_id': room_id,
            'era': era,
            'fluzoTotal': column_totals[era]["fluzo"],
            'fluzoValue': 0,  # Resetear la caja a 0
            'checkedValue': checked_value,
            'message': message,
            'consecuenciasCompleted': consecuencias_completado
        }, room=f"room_{room_id}")
        
        # Si se cumplen las condiciones de victoria, emitir evento especial
        if victory_conditions_met:
            socketio.emit('victory_conditions_met', {
                'message': "->R1"
            })
        
        return jsonify({
            "success": True,
            "fluzoTotal": column_totals[era]["fluzo"],
            "message": message,
            "consecuenciasCompleted": consecuencias_completado,
            "victory_conditions_met": victory_conditions_met
        })
    except Exception as e:
        error_msg = f"Error al comprobar fluzo: {str(e)}"
        print(error_msg)
        traceback.print_exc()
        return jsonify({"success": False, "error": error_msg})
# FunciÃ³n auxiliar para desactivar botones dependientes
def deactivate_dependent_buttons(progress, dependency_key):
    """Desactiva recursivamente todos los botones que dependen de uno especÃ­fico"""
    for era in ["pasado", "presente", "futuro"]:
        for idx, deps in GameData.button_dependencies[era].items():
            if dependency_key in deps:
                # Este botÃ³n depende del que estamos desactivando, lo desactivamos tambiÃ©n
                if progress[era][idx]:
                    progress[era][idx] = False
                    # Y propagamos la desactivaciÃ³n recursivamente
                    deactivate_dependent_buttons(progress, f"{era}-{idx}")

# FunciÃ³n auxiliar para verificar quÃ© botones estÃ¡n disponibles
def get_available_buttons(progress):
    """Verifica quÃ© botones estÃ¡n disponibles segÃºn las dependencias actuales"""
    available_buttons = {
        "pasado": [],
        "presente": [],
        "futuro": []
    }
    
    for era in ["pasado", "presente", "futuro"]:
        for i in range(len(GameData.button_info[era])):
            is_available = True
            for dep in GameData.button_dependencies[era][i]:
                dep_era, dep_idx = dep.split('-')
                dep_idx = int(dep_idx)
                if not progress[dep_era][dep_idx]:
                    is_available = False
                    break
            available_buttons[era].append(is_available)
    
    return available_buttons

# Manejador para unirse a una sala (Socket.IO)
@socketio.on('join')
def on_join(data):
    """Maneja cuando un cliente se une a una sala especÃ­fica"""
    try:
        room = data.get('room')
        if room:
            join_room(room)
            print(f"Cliente unido a sala: {room}")
            
            # Si es un administrador, unirlo a la sala admin_room
            if 'is_admin' in session and session['is_admin']:
                join_room('admin_room')
                print(f"Administrador unido a sala admin_room")
    except Exception as e:
        print(f"Error al unir a sala: {str(e)}")
        traceback.print_exc()

# Manejador para abandonar una sala (Socket.IO)
@socketio.on('leave')
def on_leave(data):
    """Maneja cuando un cliente abandona una sala especÃ­fica"""
    try:
        room = data.get('room')
        if room:
            leave_room(room)
            print(f"Cliente abandonÃ³ la sala: {room}")
            
            # Si es un administrador, hacer que abandone la sala admin_room
            if 'is_admin' in session and session['is_admin']:
                leave_room('admin_room')
                print(f"Administrador abandonÃ³ la sala admin_room")
    except Exception as e:
        print(f"Error al abandonar sala: {str(e)}")
        traceback.print_exc()

# Manejador para la desconexiÃ³n de un cliente (Socket.IO)
@socketio.on('disconnect')
def handle_disconnect():
    """Maneja la desconexiÃ³n de un cliente"""
    try:
        print(f"Cliente desconectado")
        # No es necesario hacer nada aquÃ­, Flask-SocketIO maneja automÃ¡ticamente
        # el abandono de las salas cuando un cliente se desconecta
    except Exception as e:
        print(f"Error en desconexiÃ³n: {str(e)}")
        traceback.print_exc()


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\controllers\__init__.py
--------------------------------------------------
from .auth_controller import auth_bp
from .admin_controller import admin_bp
from .room_controller import room_bp

# Esta importaciÃ³n facilita el registro de blueprints en app/__init__.py
# Por ejemplo: from app.controllers import auth_bp, admin_bp, room_bp


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\models\auth - copia.py
--------------------------------------------------
class Auth:
    """Modelo para autenticaciÃ³n y control de acceso"""
    
    # CÃ³digos de acceso para cada mesa, con su respectivo grupo y era
    _mesa_access_codes = {
        "mesa01": {"group": 1, "era": "pasado"},   # Mesa 01 accede al Grupo 1, era Pasado
        "mesa02": {"group": 1, "era": "presente"}, # Mesa 02 accede al Grupo 1, era Presente
        "mesa03": {"group": 1, "era": "futuro"},   # Mesa 03 accede al Grupo 1, era Futuro
        "mesa04": {"group": 2, "era": "pasado"},   # Mesa 04 accede al Grupo 2, era Pasado
        "mesa05": {"group": 2, "era": "presente"}, # Mesa 05 accede al Grupo 2, era Presente
        "mesa06": {"group": 2, "era": "futuro"},   # Mesa 06 accede al Grupo 2, era Futuro
        "mesa07": {"group": 3, "era": "pasado"},   # Mesa 07 accede al Grupo 3, era Pasado
        "mesa08": {"group": 3, "era": "presente"}, # Mesa 08 accede al Grupo 3, era Presente
        "mesa09": {"group": 3, "era": "futuro"},   # Mesa 09 accede al Grupo 3, era Futuro
    }
    
    # Usuarios administradores (con acceso completo)
    _admin_users = {
        "admin1": "clave1",  # Usuario: admin1, ContraseÃ±a: clave1
        "admin2": "clave2",
        "admin3": "clave3",
        "admin4": "clave4",
        "admin5": "clave5",
    }
    
    # Lista de salas/grupos disponibles
    _rooms = [{"name": f"Grupo {i+1}", "id": i+1} for i in range(2)]
    
    @classmethod
    def get_mesa_info(cls, access_code):
        """Obtiene la informaciÃ³n de una mesa a partir de su cÃ³digo de acceso"""
        access_code = access_code.strip().lower()
        return cls._mesa_access_codes.get(access_code)
    
    @classmethod
    def validate_admin(cls, username, password):
        """Valida las credenciales de un administrador"""
        return cls._admin_users.get(username) == password
    
    @classmethod
    def get_all_rooms(cls):
        """Retorna todas las salas/grupos disponibles"""
        return cls._rooms
    
    @classmethod
    def get_room_by_id(cls, room_id):
        """Busca una sala por su ID"""
        return next((r for r in cls._rooms if r["id"] == room_id), None)
    
    @classmethod
    def add_room(cls):
        """AÃ±ade una nueva sala/grupo"""
        next_id = max([r["id"] for r in cls._rooms]) + 1 if cls._rooms else 1
        new_room = {"name": f"Grupo {next_id}", "id": next_id}
        cls._rooms.append(new_room)
        
        # Crear cÃ³digos de mesa para el nuevo grupo (uno para cada era)
        last_mesa_num = 0
        for mesa_code in cls._mesa_access_codes.keys():
            if mesa_code.startswith('mesa'):
                try:
                    num = int(mesa_code[4:])
                    if num > last_mesa_num:
                        last_mesa_num = num
                except ValueError:
                    # Ignorar si el formato no es mesakk donde kk es un nÃºmero
                    pass
        
        # Crear los nuevos cÃ³digos de mesa
        for i, era in enumerate(['pasado', 'presente', 'futuro']):
            new_mesa_num = last_mesa_num + 1 + i
            new_mesa_code = f"mesa{new_mesa_num:02d}"  # Formato: mesa10, mesa11, etc.
            
            # AÃ±adir el nuevo cÃ³digo al diccionario
            cls._mesa_access_codes[new_mesa_code] = {
                "group": next_id,
                "era": era
            }
        
        return new_room
    
    @classmethod
    def get_all_mesa_codes(cls):
        """Retorna todos los cÃ³digos de mesa disponibles"""
        return cls._mesa_access_codes


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\models\auth.py
--------------------------------------------------
class Auth:
    """Modelo para autenticaciÃ³n y control de acceso"""
    
    # CÃ³digos de acceso para cada mesa, con su respectivo grupo y era
    _mesa_access_codes = {
        "mesa01": {"group": 1, "era": "pasado"},   # Mesa 01 accede al Grupo 1, era Pasado
        "mesa02": {"group": 1, "era": "presente"}, # Mesa 02 accede al Grupo 1, era Presente
        "mesa03": {"group": 1, "era": "futuro"},   # Mesa 03 accede al Grupo 1, era Futuro
        
    }
    
    # Usuarios administradores (con acceso completo)
    _admin_users = {
        "admin1": "clave1",  # Usuario: admin1, ContraseÃ±a: clave1
        "admin2": "clave2",
        "admin3": "clave3",
        "admin4": "clave4",
        "admin5": "clave5",
    }
    
    # Lista de salas/grupos disponibles
    _rooms = [{"name": f"Grupo {i+1}", "id": i+1} for i in range(2)]
    
    @classmethod
    def get_mesa_info(cls, access_code):
        """Obtiene la informaciÃ³n de una mesa a partir de su cÃ³digo de acceso"""
        access_code = access_code.strip().lower()
        return cls._mesa_access_codes.get(access_code)
    
    @classmethod
    def validate_admin(cls, username, password):
        """Valida las credenciales de un administrador"""
        return cls._admin_users.get(username) == password
    
    @classmethod
    def get_all_rooms(cls):
        """Retorna todas las salas/grupos disponibles"""
        return cls._rooms
    
    @classmethod
    def get_room_by_id(cls, room_id):
        """Busca una sala por su ID"""
        return next((r for r in cls._rooms if r["id"] == room_id), None)
    
    @classmethod
    def add_room(cls):
        """AÃ±ade una nueva sala/grupo"""
        next_id = max([r["id"] for r in cls._rooms]) + 1 if cls._rooms else 1
        new_room = {"name": f"Grupo {next_id}", "id": next_id}
        cls._rooms.append(new_room)
        
        # Crear cÃ³digos de mesa para el nuevo grupo (uno para cada era)
        last_mesa_num = 0
        for mesa_code in cls._mesa_access_codes.keys():
            if mesa_code.startswith('mesa'):
                try:
                    num = int(mesa_code[4:])
                    if num > last_mesa_num:
                        last_mesa_num = num
                except ValueError:
                    # Ignorar si el formato no es mesakk donde kk es un nÃºmero
                    pass
        
        # Crear los nuevos cÃ³digos de mesa
        for i, era in enumerate(['pasado', 'presente', 'futuro']):
            new_mesa_num = last_mesa_num + 1 + i
            new_mesa_code = f"mesa{new_mesa_num:02d}"  # Formato: mesa10, mesa11, etc.
            
            # AÃ±adir el nuevo cÃ³digo al diccionario
            cls._mesa_access_codes[new_mesa_code] = {
                "group": next_id,
                "era": era
            }
        
        return new_room
    
    @classmethod
    def get_all_mesa_codes(cls):
        """Retorna todos los cÃ³digos de mesa disponibles"""
        return cls._mesa_access_codes


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\models\game_data.py
--------------------------------------------------
import random

class GameData:
    """Modelo para los datos del juego"""
    
    # InformaciÃ³n de botones para cada era
    button_info = {
        "pasado": [
            "Thomas y Mary se han conocido.",
            "Ha empezado la financiación de un observatorio.",
            "Thomas y Mary se han inspirado en Nikola Tesla.",
            "Thomas y Mary se han casado.",
            "Se ha plantado la semilla de un Ã¡rbol.",
            "Se ha aÃ±adido \"Un noble legado\" a la zona de victoria."
        ],
        "presente": [
            "Se han fundado Industrias Corrigan.",
            "Se ha construido el observatorio.",
            "Ha empezado la investigaciÃ³n sobre el teletransporte.",
            "Se ha pagado la deuda.",
            "Se ha aÃ±adido \"Un noble legado\" a la zona de victoria."
        ],
        "futuro": [
            "Thomas y Mary han realizado un descubrimiento histÃ³rico.",
            "Thomas y Mary han ganado un Premio Nobel.",
            "Coloca una semilla en la Universidad Miskatonic PASADO.",
            "Se ha aÃ±adido \"Un noble legado\" a la zona de victoria."
        ]
    }
    
    # Dependencias de los botones
    button_dependencies = {
        "pasado": {
            0: [],  # Pasado 1: Se puede activar libremente
            1: [],  # Pasado 2: Se puede activar libremente
            2: [],  # Pasado 3: Se puede activar libremente
            3: ["pasado-0"],  # Pasado 4: Requiere Pasado 1
            4: [],   # Pasado 5: Se puede activar libremente
            5: []   # Pasado 6 (Noble legado): Se puede activar libremente
        },
        "presente": {
            0: ["pasado-0"],  # Presente 1: Requiere Pasado 1
            1: ["pasado-1"],  # Presente 2: Requiere Pasado 2
            2: ["pasado-2", "presente-1"],  # Presente 3: Requiere Pasado 3 y Presente 2
            3: [],  # Presente 4: Se puede activar libremente
            4: []   # Presente 5 (Noble legado): Se puede activar libremente
        },
        "futuro": {
            0: ["presente-0", "presente-2"],  # Futuro 1: Requiere Presente 1 y Presente 3
            1: ["futuro-0"],  # Futuro 2: Requiere Futuro 1
            2: ["pasado-4"],  # Futuro 3: Requiere Pasado 5 (semilla del Ã¡rbol)
            3: []   # Futuro 4 (Noble legado): Se puede activar libremente
        }
    }
    
    # Almacenamiento del progreso y recursos
    _game_data = {}
    
    @classmethod
    def initialize_room_data(cls, room_id):
        """Inicializa o carga datos de una sala"""
        room_key = f"room_{room_id}"
        if room_key not in cls._game_data:
            cls._game_data[room_key] = {
                "progress": {
                    "pasado": [False] * len(cls.button_info["pasado"]),
                    "presente": [False] * len(cls.button_info["presente"]),
                    "futuro": [False] * len(cls.button_info["futuro"])
                },
                "resources": {
                    "pasado": 0,
                    "presente": 0,
                    "futuro": 0,
                    "total": 0
                },
                "biff_defeats": {
                    "pasado": 0,
                    "presente": 0,
                    "futuro": 0
                },
                "biff_disabled": {
                    "pasado": False,
                    "presente": False,
                    "futuro": False
                }
            }
        # Asegurar retrocompatibilidad: si el campo biff_disabled no existe, aÃ±adirlo
        elif "biff_disabled" not in cls._game_data[room_key]:
            cls._game_data[room_key]["biff_disabled"] = {
                "pasado": False,
                "presente": False,
                "futuro": False
            }
        return cls._game_data[room_key]
    
    @classmethod
    def initialize_global_counters(cls):
        """Inicializa los contadores globales"""
        if "global_counters" not in cls._game_data:
            cls._game_data["global_counters"] = {
                "perdicion": 0,
                "reserva": 0,
                "perdicion_cycle": 1,  # Ciclo 1, 2 o 3
                "consecuencias_imprevistas": False,  # Nuevo campo para Consecuencias Imprevistas
            }
        else:
            # Asegurar que los campos existan en datos existentes
            if "perdicion_cycle" not in cls._game_data["global_counters"]:
                cls._game_data["global_counters"]["perdicion_cycle"] = 1
            if "consecuencias_imprevistas" not in cls._game_data["global_counters"]:
                cls._game_data["global_counters"]["consecuencias_imprevistas"] = False
    
        return cls._game_data["global_counters"]
    
    @classmethod
    def initialize_room_column_totals(cls, room_id):
        """Inicializa los contadores por columna en una sala"""
        room_key = f"room_{room_id}"
        room_data = cls.initialize_room_data(room_id)
        
        if "column_totals" not in room_data:
            room_data["column_totals"] = {
                "pasado": {
                    "perdicion": 0,
                    "reserva": 0
                },
                "presente": {
                    "perdicion": 0,
                    "reserva": 0
                },
                "futuro": {
                    "perdicion": 0,
                    "reserva": 0
                }
            }
        # Asegurar compatibilidad con versiones anteriores
        elif not isinstance(room_data["column_totals"].get("perdicion", {}), dict):
            # Convertir formato antiguo a nuevo formato
            old_totals = room_data["column_totals"].copy()
            room_data["column_totals"] = {
                "pasado": {
                    "perdicion": 0,
                    "reserva": 0
                },
                "presente": {
                    "perdicion": 0,
                    "reserva": 0
                },
                "futuro": {
                    "perdicion": 0,
                    "reserva": 0
                }
            }
        
        return room_data["column_totals"]
    
    @classmethod
    def save_column_totals(cls, room_id, column_totals):
        """Guarda los totales de columna en la estructura de datos en memoria"""
        room_key = f"room_{room_id}"
        if room_key in cls._game_data:
            cls._game_data[room_key]["column_totals"] = column_totals
        return True
    
    @classmethod
    def save_global_counters(cls, global_counters):
        """Guarda los contadores globales en la estructura de datos en memoria"""
        cls._game_data["global_counters"] = global_counters
        return True
    
    @classmethod
    def reset_perdicion_all_rooms(cls):
        """Reinicia el contador de perdiciÃ³n en todas las salas"""
        # Iterar por todas las salas
        for key in list(cls._game_data.keys()):
            # Solo procesar las llaves que corresponden a salas
            if key.startswith("room_"):
                # Asegurarse de que existe la estructura de column_totals
                if "column_totals" in cls._game_data[key]:
                    # Reiniciar el contador de perdiciÃ³n para todas las eras en esta sala
                    for era in ["pasado", "presente", "futuro"]:
                        if era in cls._game_data[key]["column_totals"]:
                            cls._game_data[key]["column_totals"][era]["perdicion"] = 0
        
        return True
    
    @classmethod
    def reset_all_data(cls):
        """Resetea todos los datos del juego"""
        cls._game_data = {}
        # Inicializar contadores globales para evitar errores
        cls.initialize_global_counters()
        return True


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\models\__init__.py
--------------------------------------------------
from .auth import Auth
from .game_data import GameData

# Esta importaciÃ³n permite acceder a los modelos directamente desde app.models
# Por ejemplo: from app.models import Auth, GameData


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\static\fonts\demo.html
--------------------------------------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noindex, noarchive">
    <meta name="format-detection" content="telephone=no">
    <title>Transfonter demo</title>
    <link href="stylesheet.css" rel="stylesheet">
    <style>
        /*
        http://meyerweb.com/eric/tools/css/reset/
        v2.0 | 20110126
        License: none (public domain)
        */
        html, body, div, span, applet, object, iframe,
        h1, h2, h3, h4, h5, h6, p, blockquote, pre,
        a, abbr, acronym, address, big, cite, code,
        del, dfn, em, img, ins, kbd, q, s, samp,
        small, strike, strong, sub, sup, tt, var,
        b, u, i, center,
        dl, dt, dd, ol, ul, li,
        fieldset, form, label, legend,
        table, caption, tbody, tfoot, thead, tr, th, td,
        article, aside, canvas, details, embed,
        figure, figcaption, footer, header, hgroup,
        menu, nav, output, ruby, section, summary,
        time, mark, audio, video {
            margin: 0;
            padding: 0;
            border: 0;
            font-size: 100%;
            font: inherit;
            vertical-align: baseline;
        }
        /* HTML5 display-role reset for older browsers */
        article, aside, details, figcaption, figure,
        footer, header, hgroup, menu, nav, section {
            display: block;
        }
        body {
            line-height: 1;
        }
        ol, ul {
            list-style: none;
        }
        blockquote, q {
            quotes: none;
        }
        blockquote:before, blockquote:after,
        q:before, q:after {
            content: '';
            content: none;
        }
        table {
            border-collapse: collapse;
            border-spacing: 0;
        }
        /* demo styles */
        body {
            background: #f0f0f0;
            color: #000;
        }
        .page {
            background: #fff;
            width: 920px;
            margin: 0 auto;
            padding: 20px 20px 0 20px;
            overflow: hidden;
        }
        .font-container {
            overflow-x: auto;
            overflow-y: hidden;
            margin-bottom: 40px;
            line-height: 1.3;
            white-space: nowrap;
            padding-bottom: 5px;
        }
        h1 {
            position: relative;
            background: #444;
            font-size: 32px;
            color: #fff;
            padding: 10px 20px;
            margin: 0 -20px 12px -20px;
        }
        .letters {
            font-size: 25px;
            margin-bottom: 20px;
        }
        .s10:before {
            content: '10px';
        }
        .s11:before {
            content: '11px';
        }
        .s12:before {
            content: '12px';
        }
        .s14:before {
            content: '14px';
        }
        .s18:before {
            content: '18px';
        }
        .s24:before {
            content: '24px';
        }
        .s30:before {
            content: '30px';
        }
        .s36:before {
            content: '36px';
        }
        .s48:before {
            content: '48px';
        }
        .s60:before {
            content: '60px';
        }
        .s72:before {
            content: '72px';
        }
        .s10:before, .s11:before, .s12:before, .s14:before,
        .s18:before, .s24:before, .s30:before, .s36:before,
        .s48:before, .s60:before, .s72:before {
            font-family: Arial, sans-serif;
            font-size: 10px;
            font-weight: normal;
            font-style: normal;
            color: #999;
            padding-right: 6px;
        }
        pre {
            display: block;
            padding: 9px;
            margin: 0 0 12px;
            font-family: Monaco, Menlo, Consolas, "Courier New", monospace;
            font-size: 13px;
            line-height: 1.428571429;
            color: #333;
            font-weight: normal;
            font-style: normal;
            background-color: #f5f5f5;
            border: 1px solid #ccc;
            overflow-x: auto;
            border-radius: 4px;
        }
        /* responsive */
        @media (max-width: 959px) {
            .page {
                width: auto;
                margin: 0;
            }
        }
    </style>
</head>
<body>
<div class="page">
    <div class="demo">
        <h1 style="font-family: 'AH LCG'; font-weight: normal; font-style: normal;">AH LCG icon font</h1>
        <pre title="Usage">.your-style {
    font-family: 'AH LCG';
    font-weight: normal;
    font-style: normal;
}</pre>
        <pre title="Preload (optional)">
&lt;link rel=&quot;preload&quot; href=&quot;AHLCG.woff2&quot; as=&quot;font&quot; type=&quot;font/woff2&quot; crossorigin&gt;</pre>
        <div class="font-container" style="font-family: 'AH LCG'; font-weight: normal; font-style: normal;">
            <p class="letters">
                abcdefghijklmnopqrstuvwxyz<br>
ABCDEFGHIJKLMNOPQRSTUVWXYZ<br>
                0123456789.:,;()*!?'@#&lt;&gt;$%&^+-=~
            </p>
            <p class="s10" style="font-size: 10px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s11" style="font-size: 11px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s12" style="font-size: 12px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s14" style="font-size: 14px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s18" style="font-size: 18px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s24" style="font-size: 24px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s30" style="font-size: 30px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s36" style="font-size: 36px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s48" style="font-size: 48px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s60" style="font-size: 60px;">The quick brown fox jumps over the lazy dog.</p>
            <p class="s72" style="font-size: 72px;">The quick brown fox jumps over the lazy dog.</p>
        </div>
    </div>

</div>
</body>
</html>


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\static\fonts\stylesheet.css
--------------------------------------------------
@font-face {
    font-family: 'AH LCG';
    src: url('AHLCG.woff2') format('woff2'),
        url('AHLCG.woff') format('woff');
    font-weight: normal;
    font-style: normal;
    font-display: swap;
}



Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\views\templates\admin_panel.html
--------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panel de AdministraciÃ³n - Arkham Horror</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=EB+Garamond&display=swap" rel="stylesheet">
    <!-- Agregar Socket.IO cliente -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body {
            font-family: 'EB Garamond', serif;
            margin: 0;
            padding: 15px;
            background-color: #0a0a0a;
            background-image: url('https://i.postimg.cc/8PGqXKYC/borja-pindado-ah-walkingthroughtime-borjapindado-1.jpg');
            background-position: center center;
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            color: #d4c8a8;
            min-height: 100vh;
        }
        .content-wrapper {
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        h1 {
            font-family: 'Cinzel', serif;
            color: #c0a062;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }
        .admin-title {
            background-color: #3d2e16;
            color: #c0a062;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 20px;
            font-family: 'Cinzel', serif;
            letter-spacing: 1px;
            border: 1px solid #5a4526;
        }
        .group-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .group-card {
            background-color: rgba(30, 24, 18, 0.9);
            border: 1px solid #5a4526;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
        }
        .group-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .group-name {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            color: #c0a062;
            margin-bottom: 15px;
        }
        .group-link {
            display: inline-block;
            padding: 8px 15px;
            background-color: #3d2e16;
            color: #c0a062;
            border: 1px solid #5a4526;
            border-radius: 5px;
            text-decoration: none;
            margin-top: 10px;
            transition: all 0.3s ease;
        }
        .group-link:hover {
            background-color: #5a4526;
        }
        .logout-link {
            display: inline-block;
            margin-top: 20px;
            color: #a89c8a;
            text-decoration: none;
            font-size: 16px;
            transition: color 0.3s ease;
            text-align: center;
            width: 100%;
        }
        .logout-link:hover {
            color: #c0a062;
        }
        .admin-badge {
            display: inline-block;
            background-color: #492222;
            color: #ff9999;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            margin-bottom: 15px;
            border: 1px solid #6d3636;
            text-align: center;
            width: 120px;
            margin: 0 auto 15px auto;
        }
        
        /* AnimaciÃ³n para nuevo grupo */
        @keyframes highlight {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(192, 160, 98, 0); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(192, 160, 98, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(192, 160, 98, 0); }
        }
        
        .highlight-animation {
            animation: highlight 1.5s ease-in-out;
        }
        
        /* Estilos para el botÃ³n de reinicio del servidor */
        .server-actions {
            margin-top: 30px;
            text-align: center;
            padding: 20px;
            background-color: rgba(73, 34, 34, 0.8);
            border: 1px solid #6d3636;
            border-radius: 8px;
            position: relative;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .server-actions-title {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            color: #ff9999;
            margin-bottom: 15px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        
        .server-reset-button {
            padding: 10px 20px;
            background-color: #6d2525;
            color: #ffcccc;
            border: 2px solid #8f3636;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .server-reset-button:hover {
            background-color: #8f3636;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        .warning-icon {
            display: inline-block;
            margin-right: 8px;
            font-size: 18px;
        }
        
        .alert-message {
            background-color: #3d2e16;
            color: #c0a062;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid #5a4526;
            text-align: center;
        }
        
        /* Nuevos estilos para la secciÃ³n de cÃ³digos QR */
        .qr-section {
            margin-top: 30px;
            text-align: center;
            padding: 20px;
            background-color: rgba(61, 46, 22, 0.8);
            border: 1px solid #5a4526;
            border-radius: 8px;
            position: relative;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .qr-section-title {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            color: #c0a062;
            margin-bottom: 15px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        
        .qr-section p {
            font-size: 14px;
            margin-bottom: 15px;
            color: #a89c8a;
        }
        
        .qr-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .qr-card {
            background-color: rgba(20, 16, 10, 0.8);
            border: 1px solid #5a4526;
            border-radius: 5px;
            padding: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .qr-title {
            font-family: 'Cinzel', serif;
            font-size: 14px;
            color: #c0a062;
            margin-bottom: 5px;
        }
        
        .qr-details {
            font-size: 12px;
            color: #a89c8a;
            margin-bottom: 10px;
        }
        
        .qr-link {
            display: inline-block;
            padding: 5px 10px;
            background-color: #3d2e16;
            color: #c0a062;
            border: 1px solid #5a4526;
            border-radius: 5px;
            text-decoration: none;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .qr-link:hover {
            background-color: #5a4526;
            transform: translateY(-2px);
        }
        
        /* Media query para dispositivos mÃ³viles */
        @media (max-width: 768px) {
            body {
                background-position: 30% center;
                padding: 10px;
            }
            h1 {
                font-size: 22px;
            }
            .content-wrapper {
                padding: 10px;
                margin-bottom: 10px;
            }
            .group-grid {
                grid-template-columns: 1fr;
            }
            .server-actions, .qr-section {
                padding: 15px;
            }
            .server-actions-title, .qr-section-title {
                font-size: 16px;
            }
            .server-reset-button {
                font-size: 14px;
                padding: 8px 16px;
            }
            .qr-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Inicializar Socket.IO
            const socket = io();
            
            // Escuchar actualizaciones de salas
            socket.on('room_update', function(data) {
                updateRoomGrid(data.rooms);
            });
            
            // Escuchar eventos de reinicio del servidor
            socket.on('server_reset', function(data) {
                alert(data.message);
                window.location.reload();
            });
            
            // FunciÃ³n para actualizar la cuadrÃ­cula de salas
            function updateRoomGrid(rooms) {
                const grid = document.getElementById('group-grid');
                if (!grid) return;
                
                // Guardar la referencia al Ãºltimo elemento (botÃ³n de aÃ±adir)
                const addForm = document.getElementById('add-room-form');
                
                // Limpiar la cuadrÃ­cula actual
                grid.innerHTML = '';
                
                // AÃ±adir las salas actualizadas
                rooms.forEach(room => {
                    const card = document.createElement('div');
                    card.className = 'group-card';
                    if (room.id === rooms.length) { // Si es la sala reciÃ©n aÃ±adida
                        card.classList.add('highlight-animation');
                    }
                    
                    card.innerHTML = `
                        <div class="group-name">${room.name}</div>
                        <a href="/room/${room.id}" class="group-link">Acceder</a>
                    `;
                    
                    grid.appendChild(card);
                });
                
                // Volver a aÃ±adir el formulario para agregar nueva sala
                if (addForm) {
                    grid.appendChild(addForm);
                }
            }
            
            // Agregar el manejador para el botÃ³n de reinicio de ciclo de perdiciÃ³n
            document.getElementById('reset-perdicion-cycle').addEventListener('click', function() {
                if (confirm("Â¿EstÃ¡s seguro de que deseas reiniciar el ciclo de perdiciÃ³n? Esto volverÃ¡ al primer ciclo y pondrÃ¡ el contador a 0.")) {
                    fetch('/admin/reset_perdicion_cycle', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            alert("Ciclo de perdiciÃ³n reiniciado correctamente");
                        } else {
                            alert("Error: " + data.error);
                        }
                    })
                    .catch(error => {
                        console.error("Error:", error);
                        alert("Ha ocurrido un error al reiniciar el ciclo de perdiciÃ³n");
                    });
                }
            });
        });
    </script>
</head>
<body>
    <div class="content-wrapper">
        <h1>Panel de AdministraciÃ³n</h1>
        <div class="admin-badge">ADMINISTRADOR</div>
        
        {% if get_flashed_messages(category_filter=["success"]) %}
            <div class="alert-message">
                {{ get_flashed_messages(category_filter=["success"])[0] }}
            </div>
        </div>
        
        <div class="server-actions">
            <div class="server-actions-title">Acciones del Servidor</div>
            
            <div style="margin-bottom: 15px;">
                <button id="reset-perdicion-cycle" class="server-reset-button" style="background-color: #3d2e16; border-color: #5a4526;">
                    Reiniciar Ciclo de PerdiciÃ³n
                </button>
            </div>
            
            <form action="{{ url_for('admin.reset_server') }}" method="post" id="server-reset-form">
                <!-- BotÃ³n de tipo submit en lugar de button -->
                <input type="submit" value="âš  Reiniciar Servidor" class="server-reset-button" 
                       onclick="return confirm('Â¡ADVERTENCIA! EstÃ¡s a punto de reiniciar COMPLETAMENTE el servidor. Todos los datos de progreso, recursos y contadores serÃ¡n borrados. Esta acciÃ³n no se puede deshacer. Â¿EstÃ¡s seguro de que deseas continuar?') && 
                               confirm('Por favor, confirma nuevamente que deseas reiniciar el servidor. Todos los datos se perderÃ¡n.');">
            </form>
            
            <p style="font-size: 12px; margin-top: 10px; color: #ff9999;">
                Esta acciÃ³n reiniciarÃ¡ todos los datos del juego: progreso, recursos y contadores.
            </p>
        </div>
        
        <a href="{{ url_for('auth.logout') }}" class="logout-link">Cerrar SesiÃ³n</a>
    </div>
</body>
</html>
        {% endif %}
        
        <div class="admin-title">Selecciona un grupo para administrar</div>
        
        <div class="group-grid" id="group-grid">
            {% for room in rooms %}
                <div class="group-card">
                    <div class="group-name">{{ room.name }}</div>
                    <a href="{{ url_for('game.room', room_id=room.id) }}" class="group-link">Acceder</a>
                </div>
            {% endfor %}
            
            <form action="{{ url_for('admin.add_room') }}" method="post" id="add-room-form" class="group-card" style="background-color: rgba(61, 46, 22, 0.7);">
                <div class="group-name">AÃ±adir Grupo</div>
                <button type="submit" class="group-link" style="cursor: pointer; border: 1px dashed #5a4526;">+ Crear</button>
            </form>
        </div>
        
        <!-- SecciÃ³n de CÃ³digos QR -->
        <div class="qr-section">
            <div class="qr-section-title">CÃ³digos QR para Mesas</div>
            
            <p>Genera e imprime cÃ³digos QR para que los jugadores puedan acceder directamente a sus mesas asignadas escaneando el cÃ³digo con su telÃ©fono.</p>
            
            <a href="{{ url_for('admin.print_all_qr') }}" class="group-link" style="margin-bottom: 20px;">Ver e Imprimir Todos los QR</a>
            
            <div class="qr-grid">
                {% for mesa_code, mesa_info in mesa_access_codes.items() %}
                    {% set group_id = mesa_info.group %}
                    {% set era = mesa_info.era %}
                    {% set mesa_name = "Mesa " + mesa_code[4:].zfill(2).upper() %}
                    <div class="qr-card">
                        <div class="qr-title">{{ mesa_name }}</div>
                        <div class="qr-details">Grupo {{ group_id }} - {{ era|capitalize }}</div>
                        <a href="{{ url_for('admin.generate_qr', mesa_code=mesa_code) }}" class="qr-link" download="qr_{{ mesa_code }}.png">Descargar QR</a>
                    </div>
                {% endfor %}
            </div>


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\views\templates\era.html
--------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% if mesa_name %}{{ mesa_name }}{% else %}{{ room.name }} - {{ era|capitalize }}{% endif %} - Arkham Horror</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=EB+Garamond&display=swap" rel="stylesheet">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
@font-face {
  font-family: 'AHLCG';
  src: url('{{ url_for("static", filename="fonts/AHLCG.woff") }}') format('woff');
  font-weight: normal;
  font-style: normal;
}
        /* Estilos Base */
        body {
            font-family: 'EB Garamond', serif;
            margin: 0;
            padding: 15px;
            background-color: #0a0a0a;
            background-image: url('https://i.postimg.cc/8PGqXKYC/borja-pindado-ah-walkingthroughtime-borjapindado-1.jpg');
            background-position: center center;
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            color: #d4c8a8;
            min-height: 100vh;
        }
        
        .content-wrapper {
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        
        h1 {
            font-family: 'Cinzel', serif;
            color: #c0a062;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }
        
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #a89c8a;
            text-decoration: none;
            font-size: 16px;
            transition: color 0.3s ease;
        }
        
        .back-link:hover {
            color: #c0a062;
        }
        
        /* Contenedores y tÃ­tulos de secciÃ³n */
        .section-container {
            background-color: rgba(20, 20, 20, 0.8);
            border: 1px solid #3a3223;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.7);
            margin: 20px auto;
            max-width: 800px;
            position: relative;
            overflow: hidden;
        }
        
        .section-title {
            font-family: 'Cinzel', serif;
            font-size: 24px;
            font-weight: bold;
            color: #c0a062;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }
        
        /* Badges */
        .admin-badge {
            display: inline-block;
            background-color: #492222;
            color: #ff9999;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            margin: 0 auto 15px auto;
            border: 1px solid #6d3636;
            text-align: center;
            width: 150px;
        }
        
        .mesa-badge {
            display: inline-block;
            background-color: #3d2e16;
            color: #c0a062;
            padding: 5px 15px;
            border-radius: 5px;
            font-size: 16px;
            font-family: 'Cinzel', serif;
            margin: 0 auto 15px auto;
            border: 1px solid #5a4526;
            text-align: center;
            letter-spacing: 1px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
/* Estilos para la secciÃ³n de anuncios */
        .announcements-grid {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .game-button {
            background-color: #232323;
            border: 1px solid #3a3223;
            padding: 20px;
            border-radius: 5px;
            font-size: 16px;
            text-align: left;
            display: flex;
            align-items: center;
            position: relative;
            color: #a89c8a;
            min-height: 70px;
            font-family: 'EB Garamond', serif;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .game-button:hover:not(.disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        
        .game-button.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .status-badge {
            position: absolute;
            bottom: 5px;
            right: 5px;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #c0a062;
            padding: 3px 8px;
            border-radius: 10px;
            border: 1px solid rgba(192, 160, 98, 0.5);
        }
        
        /* Estilos especÃ­ficos para cada era */
        .era-pasado .game-button.available {
            background-color: #2d4a2d;
            border-color: #4CAF50;
        }
        
        .era-pasado .game-button.active {
            background-color: #376937;
            color: #d2e3d2;
            border-color: #6abf6a;
        }
        
        .era-presente .game-button.available {
            background-color: #4a4a2d;
            border-color: #b5b552;
        }
        
        .era-presente .game-button.active {
            background-color: #5c5c30;
            color: #f0f0d8;
            border-color: #d6d670;
        }
        
        .era-futuro .game-button.available {
            background-color: #4a2d2d;
            border-color: #b55252;
        }
        
        .era-futuro .game-button.active {
            background-color: #5c3030;
            color: #f0d8d8;
            border-color: #d67070;
        }
        
        .era-futuro .button-futuro-2.available {
            background-color: #2d3a4a;
            border-color: #5277b6;
        }
        
        .era-futuro .button-futuro-2.active {
            background-color: #30425c;
            color: #d8e4f0;
            border-color: #70a1d6;
        }
        
        /* Estilos para el botÃ³n de Biff Tannen */
        .biff-button-container {
            text-align: center;
            margin: 10px 0;
        }
        
        .biff-button {
            padding: 15px 25px;
            background: linear-gradient(145deg, #e6bc54, #c0a062);
            color: #3d2e16;
            border: 2px solid #daa520;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
        }
        
        .biff-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.4);
            background: linear-gradient(145deg, #edcc79, #d4b775);
        }
/* Estilos completos para la secciÃ³n de recursos */
        .resources-flex {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: nowrap; /* Evita que los elementos se envuelvan */
        }
        
        .resource-block {
            flex: 1;
            min-width: 0; /* Permite que el bloque se comprima si es necesario */
            background-color: rgba(30, 24, 18, 0.9);
            border: 1px solid #5a4526;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
        }
        
        .resource-block h3 {
            font-family: 'Cinzel', serif;
            color: #c0a062;
            font-size: 16px;
            margin: 0 0 8px 0;
            white-space: nowrap; /* Evita que el tÃ­tulo se divida en mÃºltiples lÃ­neas */
            overflow: hidden;
            text-overflow: ellipsis; /* Muestra '...' si el texto es demasiado largo */
        }
        
        /* Botones + y - con centrado corregido */
        .btn-plus, .btn-minus {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 1px solid #5a4526;
            background-color: #3d2e16;
            color: #c0a062;
            font-size: 20px;
            cursor: pointer;
            margin: 5px auto;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            
            /* Mejoras para centrar el texto */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0; /* Eliminar cualquier padding */
            line-height: 1; /* Corregir la altura de lÃ­nea */
            text-align: center;
        }
        
        .btn-plus:hover, .btn-minus:hover, .btn-send:hover {
            background-color: #5a4526;
            transform: translateY(-2px);
            transition: all 0.2s ease;
        }
        
        .btn-minus {
            background-color: #492222;
            border-color: #6d3636;
            margin-bottom: 8px;
        }
        
        .btn-minus:hover {
            background-color: #6d3636;
        }
        
        .btn-send {
            padding: 6px 10px;
            background-color: #2d405a;
            color: #a0c0e0;
            border: 1px solid #405c8a;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 13px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            display: block;
            margin: 0 auto 10px auto;
            width: 80%; /* Ancho fijo para que quepa bien en pantallas pequeÃ±as */
            transition: all 0.2s ease;
        }
        
        .value-display {
            width: 50px;
            height: 36px;
            border: 1px solid #5a4526;
            border-radius: 5px;
            margin: 5px auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            background-color: rgba(20, 16, 10, 0.8);
            color: #c0a062;
        }
        
        /* Estilos para los contadores Enviado y Global */
        .total-display, .global-display {
            margin-top: 6px;
            font-size: 13px;
            color: #a89c8a;
            padding-top: 6px;
        }
        
        .total-display {
            border-top: 1px dotted #5a4526;
            margin-bottom: 2px;
        }
        
        .global-display {
            color: #b7a992;
            margin-bottom: 0;
        }
        
        .total-display span:last-child, .global-display span:last-child {
            color: #c0a062;
            font-weight: bold;
            margin-left: 3px;
        }
        
        .global-display span:last-child {
            color: #d4b775; /* Color un poco mÃ¡s claro para diferenciarlo */
        }
        
        /* AnimaciÃ³n para resaltar actualizaciones */
        @keyframes highlight {
            0% { transform: scale(1); box-shadow: 0 0 0 rgba(192, 160, 98, 0); }
            50% { transform: scale(1.03); box-shadow: 0 0 20px rgba(192, 160, 98, 0.8); }
            100% { transform: scale(1); box-shadow: 0 0 0 rgba(192, 160, 98, 0); }
        }
        
        .highlight-animation {
            animation: highlight 1s ease-in-out;
        }
/* Estilos para los botones de reset */
        .reset-buttons-container {
            margin-top: 10px;
            text-align: right;
        }

        .reset-button {
            background-color: #492222;
            color: #ff9999;
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #6d3636;
            font-size: 12px;
            cursor: pointer;
            margin-left: 5px;
            transition: all 0.2s ease;
        }

        .reset-button:hover {
            background-color: #6d3636;
            transform: translateY(-2px);
        }
        
        /* Estilos para la notificaciÃ³n del juego */
        .game-notification {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .game-notification.show {
            opacity: 1;
            pointer-events: auto;
        }

        .notification-content {
            background-color: rgba(30, 24, 18, 0.9);
            border: 2px solid #c0a062;
            border-radius: 8px;
            padding: 30px;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
        }

        .notification-content p {
            font-family: 'Cinzel', serif;
            color: #c0a062;
            font-size: 24px;
            margin-bottom: 20px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
        }

        .notification-btn {
            padding: 10px 25px;
            background-color: #3d2e16;
            color: #c0a062;
            border: 1px solid #5a4526;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .notification-btn:hover {
            background-color: #5a4526;
            transform: translateY(-2px);
        }

        /* Estilos para controles deshabilitados */
        .btn-plus.disabled, .btn-minus.disabled, .btn-send.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        .cycle-indicator {
            display: block;
            width: fit-content;
            margin: 5px auto 8px auto;
            font-size: 12px;
            background-color: #492222;
            color: #ff9999;
            padding: 3px 8px;
            border-radius: 3px;
            border: 1px solid #6d3636;
            text-align: center;
        }

        /* Estilos para Fluzo desactivado */
        .fluzo-disabled {
            opacity: 0.7;
            background-color: rgba(20, 20, 20, 0.9);
            pointer-events: none;
        }

        .fluzo-disabled h3 {
            color: #8a7a58; /* Color mÃ¡s apagado */
        }


/* Responsive para mÃ³viles (ajusta el tamaÃ±o pero mantiene la disposiciÃ³n horizontal) */
        @media (max-width: 600px) {
            body {
                background-position: 30% center;
                padding: 10px;
            }
            
            h1 {
                font-size: 22px;
            }
            
            .content-wrapper {
                padding: 10px;
                margin-bottom: 10px;
            }
            
            .section-container {
                padding: 15px;
                margin: 15px auto;
            }
            
            .section-title {
                font-size: 20px;
                margin-bottom: 15px;
            }
            
            .game-button {
                padding: 15px;
                font-size: 14px;
                min-height: 60px;
            }
            
            .status-badge {
                font-size: 10px;
                padding: 2px 6px;
            }
            
            .resources-flex {
                gap: 5px; /* Espacio mÃ¡s pequeÃ±o entre columnas */
            }
            
            .resource-block {
                padding: 8px 5px;
            }
            
            .resource-block h3 {
                font-size: 14px;
                margin-bottom: 5px;
            }
            
            .btn-plus, .btn-minus {
                width: 30px;
                height: 30px;
                font-size: 16px;
                
                /* Asegurar que sigue centrado */
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                line-height: 1;
            }
            
            .value-display {
                width: 40px;
                height: 30px;
                font-size: 16px;
            }
            
            .btn-send {
                padding: 5px 8px;
                font-size: 12px;
                width: 90%;
            }
            
            .total-display, .global-display {
                font-size: 12px;
            }
            
            .reset-buttons-container {
                text-align: center;
                margin-bottom: 15px;
            }
            
            .reset-button {
                font-size: 11px;
                padding: 4px 8px;
                margin-bottom: 5px;
            }
        }
        
        /* Para pantallas muy pequeÃ±as, reducir aÃºn mÃ¡s pero mantener horizontal */
        @media (max-width: 360px) {
            .resources-flex {
                gap: 3px;
            }
            
            .resource-block {
                padding: 5px 3px;
            }
            
            .btn-plus, .btn-minus {
                width: 28px;
                height: 28px;
                font-size: 14px;
                margin: 3px auto;
                
                /* Asegurar que sigue centrado */
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
                line-height: 1;
            }
            
            .value-display {
                width: 36px;
                height: 28px;
                font-size: 14px;
            }
            
            .btn-send {
                padding: 4px 6px;
                font-size: 11px;
                margin-bottom: 6px;
            }
            
            .total-display, .global-display {
                font-size: 11px;
            }

            /* Estilo para el botÃ³n de Biff cuando estÃ¡ desactivado */
            .biff-button.disabled {
                opacity: 0.5;
                cursor: not-allowed;
                background: linear-gradient(145deg, #a8a8a8, #888888);
                color: #333333;
                text-decoration: line-through;
                border-color: #666666;
                box-shadow: none;
                pointer-events: none;
            }

            .biff-button.disabled:hover {
                transform: none;
                box-shadow: none;
                background: linear-gradient(145deg, #a8a8a8, #888888);
            }

        }

/* Estilos para la notificaciÃ³n de victoria */
#victory-notification {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    opacity: 0;
    transition: opacity 0.5s ease;
    pointer-events: none;
}

#victory-notification.show {
    opacity: 1;
    pointer-events: auto;
}

#victory-notification .notification-content {
    background-color: rgba(30, 20, 10, 0.95);
    border: 3px solid #ffd700;
    border-radius: 8px;
    padding: 40px;
    max-width: 500px;
    text-align: center;
    box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);
    animation: victoryPulse 2s infinite alternate;
}

#victory-notification p {
    font-family: 'Cinzel', serif;
    color: #ffd700;
    font-size: 32px;
    margin-bottom: 30px;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}

#victory-notification .notification-btn {
    padding: 12px 30px;
    background-color: #443311;
    color: #ffd700;
    border: 2px solid #ffd700;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Cinzel', serif;
    font-size: 18px;
    transition: all 0.3s ease;
    box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
}

#victory-notification .notification-btn:hover {
    background-color: #664411;
    transform: translateY(-3px);
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
}

@keyframes victoryPulse {
    0% {
        transform: scale(1);
    }
    100% {
        transform: scale(1.03);
    }
}

/* Estilos para el botÃ³n de preparaciÃ³n */
.prep-button {
    padding: 5px 12px;
    background: linear-gradient(145deg, #6a4b2b, #8a6b4b);
    color: #f0d8a8;
    border: 1px solid #c0a062;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Cinzel', serif;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

.prep-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
    background: linear-gradient(145deg, #7a5b3b, #9a7b5b);
}

/* Estilos para el modal */
.prep-modal {
    display: none;
    position: fixed;
    z-index: 2000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.85);
    animation: fadeIn 0.3s ease-in;
}

.prep-modal-content {
    position: relative;
    background-color: rgba(30, 24, 18, 0.95);
    margin: 5% auto;
    padding: 25px;
    border: 2px solid #c0a062;
    border-radius: 8px;
    width: 90%;
    max-width: 800px;
    box-shadow: 0 0 25px rgba(0, 0, 0, 0.7);
    animation: slideDown 0.4s ease-out;
}

.prep-modal-content h2 {
    font-family: 'Cinzel', serif;
    color: #c0a062;
    text-align: center;
    margin-bottom: 20px;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
}

.prep-modal-content img {
    max-width: 100%;
    height: auto;
    display: block;
    margin: 0 auto;
    border: 1px solid #5a4526;
    border-radius: 5px;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
}

.close-modal {
    position: absolute;
    top: 10px;
    right: 15px;
    color: #c0a062;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
}

.close-modal:hover {
    color: #ffd700;
    transform: scale(1.2);
}

@keyframes fadeIn {
    from {opacity: 0;}
    to {opacity: 1;}
}

@keyframes slideDown {
    from {transform: translateY(-50px); opacity: 0;}
    to {transform: translateY(0); opacity: 1;}
}

/* Responsive */
@media (max-width: 600px) {
    .prep-button {
        font-size: 12px;
        padding: 4px 10px;
    }
    
    .prep-modal-content {
        width: 95%;
        padding: 15px;
        margin: 10% auto;
    }
    
    .prep-modal-content h2 {
        font-size: 18px;
    }
}

/* Estilos adicionales para navegaciÃ³n de imÃ¡genes */
.image-container {
    position: relative;
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
}

.prep-image {
    max-width: 100%;
    height: auto;
    display: none;
    margin: 0 auto 15px;
    border: 1px solid #5a4526;
    border-radius: 5px;
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
}

.prep-image.active {
    display: block;
    animation: fadeIn 0.5s ease-in;
}

.image-navigation {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 15px;
    padding: 10px 0;
}

.nav-button {
    padding: 8px 15px;
    background: linear-gradient(145deg, #5a3d1d, #7a5d3d);
    color: #f0d8a8;
    border: 1px solid #c0a062;
    border-radius: 4px;
    cursor: pointer;
    font-family: 'Cinzel', serif;
    font-size: 14px;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    margin: 0 15px;
}

.nav-button:hover {
    transform: translateY(-2px);
    background: linear-gradient(145deg, #6a4d2d, #8a6d4d);
}

.nav-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
}

#image-counter {
    font-family: 'EB Garamond', serif;
    color: #c0a062;
    font-size: 16px;
    min-width: 50px;
    text-align: center;
}

    </style>
<script>
        // Variables para almacenar los totales globales
        const globalTotals = {
            'perdicion': 0,
            'reserva': 0,
            'perdicion_cycle': 1
        };
        
        // FunciÃ³n para confirmar el desmarcado de anuncios
        function confirmDemarking(buttonIdx, isActive) {
            // Obtener el elemento del botÃ³n actual para verificar su estado real
            const buttonElement = document.querySelector(`#form-button-${buttonIdx} .game-button`);
            
            // Verificar si el botÃ³n tiene la clase 'active', lo que indica que estÃ¡ marcado
            const isCurrentlyActive = buttonElement && buttonElement.classList.contains('active');
            
            // Solo mostrar confirmaciÃ³n si realmente estamos desmarcando (estÃ¡ activo actualmente)
            if (isCurrentlyActive) {
                return confirm(`Â¿EstÃ¡s seguro de que deseas desmarcar este anuncio? 
Si lo haces, todos los anuncios que dependan de Ã©ste tambiÃ©n se desmarcarÃ¡n.`);
            }
            
            // Si estamos marcando (no estÃ¡ activo actualmente), no necesitamos confirmaciÃ³n
            return true;
        }
        
// ========== PERDICIÃ“N ==========
// FunciÃ³n para actualizar el valor de perdiciÃ³n en la interfaz
function updatePerdicionValue(change) {
    // Verificar si estamos en el ciclo final
    if (globalTotals['perdicion_cycle'] > 3) {
        showNotification("El contador de perdiciÃ³n ha completado todos sus ciclos.");
        return;
    }
    
    const valueElement = document.getElementById('perdicion-value');
    if (!valueElement) {
        console.error("Elemento perdicion-value no encontrado");
        return;
    }
    
    let currentValue = parseInt(valueElement.innerText || '0');
    currentValue += change;
    
    // Permitir valores negativos pero con lÃ­mite
    if (currentValue < 0) {
        // El valor negativo no puede ser menor que el negativo del valor global
        if (Math.abs(currentValue) > globalTotals['perdicion']) {
            currentValue = -globalTotals['perdicion'];
        }
    }
    
    valueElement.innerText = currentValue;
}

// FunciÃ³n para enviar el valor de perdiciÃ³n al servidor
function sendPerdicionValue() {
    // Verificar si estamos en el ciclo final
    if (globalTotals['perdicion_cycle'] > 3) {
        showNotification("El contador de perdiciÃ³n ha completado todos sus ciclos.");
        return;
    }

    const valueElement = document.getElementById('perdicion-value');
    if (!valueElement) {
        console.error("Elemento perdicion-value no encontrado");
        return;
    }

    const currentValue = parseInt(valueElement.innerText || '0');

    if (currentValue === 0) {
        return; // No enviar si el valor es cero
    }

    // Verificar lÃ­mite para valores negativos
    if (currentValue < 0) {
        // Verificar que no se intente reducir mÃ¡s allÃ¡ de cero en el global
        if (Math.abs(currentValue) > globalTotals['perdicion']) {
            // Informar al usuario y limitar el valor al mÃ¡ximo permitido
            const maxNegative = -globalTotals['perdicion'];
            showNotification(`No se puede reducir mÃ¡s allÃ¡ de 0. Valor ajustado a ${maxNegative}.`);
            
            // Ajustar el valor al mÃ¡ximo permitido
            valueElement.innerText = maxNegative.toString();
            return;
        }
    }

    // Resetear el contador a 0
    valueElement.innerText = '0';

    // Guardamos el ciclo actual antes de enviar
    const currentCycle = globalTotals['perdicion_cycle'];
    
    // Enviar al servidor usando la nueva ruta especÃ­fica para perdiciÃ³n
    fetch('/update_perdicion/{{ room.id }}/{{ era }}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            amount: currentValue
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Error de red: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Actualizar total local con datos del servidor
            const totalElement = document.getElementById('perdicion-total');
            if (totalElement && data.columnTotal !== undefined) {
                totalElement.innerText = data.columnTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                totalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    totalElement.classList.remove('highlight-animation');
                }, 1000);
            }
    
            // Actualizar total global
            const globalElement = document.getElementById('perdicion-global');
            if (globalElement && data.globalTotal !== undefined) {
                globalTotals['perdicion'] = data.globalTotal;
                globalElement.innerText = data.globalTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                globalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    globalElement.classList.remove('highlight-animation');
                }, 1000);
            }
            
            // Actualizar el ciclo de perdiciÃ³n si cambiÃ³
            if (data.perdicionCycle !== undefined) {
                updatePerdicionCycle(data.perdicionCycle);
            }
            
            // Mostrar notificaciÃ³n si existe
            if (data.notification) {
                showNotification(data.notification);
            }
        } else if (data.error) {
            // Mostrar error si existe
            showNotification("Error: " + data.error);
            // Restaurar el valor en caso de error
            valueElement.innerText = currentValue.toString();
        }
    })
    .catch(error => {
        console.error("Error al enviar perdiciÃ³n:", error);
        showNotification("Error de conexiÃ³n: No se pudo enviar el valor de perdiciÃ³n");
        // Restaurar el valor en caso de error
        valueElement.innerText = currentValue.toString();
    });
}


// FunciÃ³n para activar/desactivar Fluzo basado en el ciclo de perdiciÃ³n
function toggleFluzoBasedOnCycle(cycle, isInitialLoad = false) {
    const fluzoBlock = document.querySelector('.resource-block:nth-child(3)'); // La tercera columna es Fluzo
    const fluzoBtns = fluzoBlock.querySelectorAll('button');
    const fluzoValue = fluzoBlock.querySelector('#fluzo-value');
    
    if (!fluzoBlock) return;
    
    if (cycle === 1) {
        // Desactivar Fluzo en Plan 1a
        fluzoBlock.classList.add('fluzo-disabled');
        fluzoBtns.forEach(btn => {
            btn.disabled = true;
            btn.classList.add('disabled');
        });
        if (fluzoValue) {
            fluzoValue.style.opacity = '0.5';
        }
    } else {
        // Activar Fluzo en otros planes
        fluzoBlock.classList.remove('fluzo-disabled');
        fluzoBtns.forEach(btn => {
            btn.disabled = false;
            btn.classList.remove('disabled');
        });
        if (fluzoValue) {
            fluzoValue.style.opacity = '1';
            // Asegurarnos que la caja siempre muestre 0
            fluzoValue.innerText = '0';
        }
        
        // Si estamos pasando del ciclo 1 al ciclo 2 (no en carga inicial)
        if (cycle === 2 && !isInitialLoad) {
            // Valores posibles
            const possibleValues = [70, 71, 72, 73, 74, 75, 80, 81, 82, 83, 84, 85];
            
            // Seleccionar un valor aleatorio
            const randomValue = possibleValues[Math.floor(Math.random() * possibleValues.length)];
            
            // Llamar al servidor para establecer el valor aleatorio
            setRandomFluzoValue(randomValue);
        }
    }
}

// FunciÃ³n modificada para establecer un valor aleatorio para Fluzo
function setRandomFluzoValue(newValue) {
    // No actualizar la caja, solo enviamos al servidor
    
    // Enviar el valor al servidor
    fetch('/set_fluzo_value/{{ room.id }}/{{ era }}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            value: newValue,
            silent: true  // Indicador para no mostrar notificaciÃ³n
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Error de red: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Actualizar solo el total con el valor del servidor
            const totalElement = document.getElementById('fluzo-total');
            if (totalElement && data.fluzoTotal !== undefined) {
                totalElement.innerText = data.fluzoTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                totalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    totalElement.classList.remove('highlight-animation');
                }, 1000);
            }
            
            // Mantener la caja en 0
            const valueElement = document.getElementById('fluzo-value');
            if (valueElement) {
                valueElement.innerText = '0';
            }
            
            // Ya NO mostramos notificaciÃ³n sobre el valor aleatorio
        } else if (data.error) {
            // Mostrar error (mantenemos esto para diagnÃ³stico)
            showNotification("Error: " + data.error);
        }
    })
    .catch(error => {
        console.error("Error al establecer valor aleatorio de fluzo:", error);
        showNotification("Error de conexiÃ³n: No se pudo establecer el valor de fluzo");
    });
}

// Modificar la funciÃ³n existente updatePerdicionCycle para detectar el cambio de ciclo
function updatePerdicionCycle(cycle) {
    // Guardar el ciclo anterior para detectar la transiciÃ³n especÃ­fica de 2 a 3
    const previousCycle = globalTotals['perdicion_cycle'];
    
    // Actualizar el valor global
    globalTotals['perdicion_cycle'] = cycle;
    
    const cycleIndicator = document.getElementById('perdicion-cycle');
    if (cycleIndicator) {
        let cycleText = "";
        switch(cycle) {
            case 1:
                cycleText = "Plan 1a";
                break;
            case 2:
                cycleText = "Plan 1a. Primer avance";
                break;
            case 3:
                cycleText = "Plan 1a. Segundo avance";
                break;
            default:
                cycleText = "->R2";
                break;
        }
        cycleIndicator.textContent = cycleText;
        
        // Si estamos en el ciclo 4 (despuÃ©s del tercer ciclo), deshabilitar controles de perdiciÃ³n
        if (cycle > 3) {
            disablePerdicionControls();
        } else {
            enablePerdicionControls();
        }
        
        // Activar/desactivar Fluzo segÃºn el ciclo
        toggleFluzoBasedOnCycle(cycle);
        
        // Detectar la transiciÃ³n especÃ­fica del ciclo 2 al ciclo 3
        if (previousCycle === 2 && cycle === 3) {
            // Cuando cambiamos al "Plan 1a. Segundo avance", ajustar el valor de Fluzo
            adjustFluzoBasedOnRules();
        }
    }
}

// Nueva funciÃ³n para ajustar el valor de Fluzo segÃºn las reglas especificadas
function adjustFluzoBasedOnRules() {
    // Obtener el valor actual de Fluzo
    const fluzoTotalElement = document.getElementById('fluzo-total');
    if (!fluzoTotalElement) return;
    
    const currentFluzoValue = parseInt(fluzoTotalElement.innerText || '0');
    let newFluzoValue = currentFluzoValue;
    
    // Aplicar las reglas de ajuste:
    if (currentFluzoValue > 86) {
        newFluzoValue = currentFluzoValue - 10;
    } else if (currentFluzoValue < 76) {
        newFluzoValue = currentFluzoValue + 10;
    } else if (currentFluzoValue >= 80 && currentFluzoValue <= 82) {
        newFluzoValue = currentFluzoValue - 5;
    }
    
    // Si el valor ha cambiado, actualizarlo en el servidor
    if (newFluzoValue !== currentFluzoValue) {
        // Enviar directamente el valor al servidor sin modificar la caja
        fetch('/set_fluzo_value/{{ room.id }}/{{ era }}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                value: newFluzoValue,
                silent: false  // Ahora mostramos notificaciÃ³n
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Error de red: ' + response.status);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // El servidor ya enviarÃ¡ la actualizaciÃ³n a travÃ©s de WebSocket
                // y mostrarÃ¡ la notificaciÃ³n cuando llegue el evento
                //showNotification("El nivel de Fluzo condensado ha sido alterado");
            }
        })
        .catch(error => {
            console.error("Error al ajustar valor de fluzo:", error);
        });
    }
}

// ========== RESERVA ==========
// FunciÃ³n para actualizar el valor de reserva en la interfaz
function updateReservaValue(change) {
    const valueElement = document.getElementById('reserva-value');
    if (!valueElement) {
        console.error("Elemento reserva-value no encontrado");
        return;
    }
    
    let currentValue = parseInt(valueElement.innerText || '0');
    currentValue += change;
    
    // Permitir valores negativos pero con lÃ­mite
    if (currentValue < 0) {
        // El valor negativo no puede ser menor que el negativo del valor global
        if (Math.abs(currentValue) > globalTotals['reserva']) {
            currentValue = -globalTotals['reserva'];
        }
    }
    
    valueElement.innerText = currentValue;
}

// FunciÃ³n para enviar el valor de reserva al servidor
function sendReservaValue() {
    const valueElement = document.getElementById('reserva-value');
    if (!valueElement) {
        console.error("Elemento reserva-value no encontrado");
        return;
    }

    const currentValue = parseInt(valueElement.innerText || '0');

    if (currentValue === 0) {
        return; // No enviar si el valor es cero
    }

    // Verificar lÃ­mite para valores negativos
    if (currentValue < 0) {
        // Verificar que no se intente reducir mÃ¡s allÃ¡ de cero en el global
        if (Math.abs(currentValue) > globalTotals['reserva']) {
            // Informar al usuario y limitar el valor al mÃ¡ximo permitido
            const maxNegative = -globalTotals['reserva'];
            showNotification(`No se puede reducir mÃ¡s allÃ¡ de 0. Valor ajustado a ${maxNegative}.`);
            
            // Ajustar el valor al mÃ¡ximo permitido
            valueElement.innerText = maxNegative.toString();
            return;
        }
    }

    // Resetear el contador a 0
    valueElement.innerText = '0';

    // Enviar al servidor usando la ruta especÃ­fica para reserva
    fetch('/update_reserva/{{ room.id }}/{{ era }}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            amount: currentValue
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Error de red: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Actualizar total local con datos del servidor
            const totalElement = document.getElementById('reserva-total');
            if (totalElement && data.columnTotal !== undefined) {
                totalElement.innerText = data.columnTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                totalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    totalElement.classList.remove('highlight-animation');
                }, 1000);
            }
    
            // Actualizar total global
            const globalElement = document.getElementById('reserva-global');
            if (globalElement && data.globalTotal !== undefined) {
                globalTotals['reserva'] = data.globalTotal;
                globalElement.innerText = data.globalTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                globalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    globalElement.classList.remove('highlight-animation');
                }, 1000);
            }
        } else if (data.error) {
            // Mostrar error si existe
            showNotification("Error: " + data.error);
            // Restaurar el valor en caso de error
            valueElement.innerText = currentValue.toString();
        }
    })
    .catch(error => {
        console.error("Error al enviar reserva:", error);
        showNotification("Error de conexiÃ³n: No se pudo enviar el valor de reserva");
        // Restaurar el valor en caso de error
        valueElement.innerText = currentValue.toString();
    });
}

// ========== FLUZO ==========

// FunciÃ³n para actualizar el valor de Fluzo
function updateFluzoValue(change) {
    // Si Consecuencias Imprevistas ya estÃ¡ completado, no permitir cambios
    if (consecuenciasImprevistasCompleted) {
        showNotification("Se ha completado Consecuencias Imprevistas. Fluzo condensado estÃ¡ bloqueado.");
        return;
    }

    const valueElement = document.getElementById('fluzo-value');
    if (!valueElement) {
        console.error("Elemento fluzo-value no encontrado");
        return;
    }
    
    // Obtener el valor actual y aplicar el cambio
    let currentValue = parseInt(valueElement.innerText || '0');
    let newValue = currentValue + change;
    
    // Actualizar el valor en pantalla inmediatamente
    valueElement.innerText = newValue;
}

// Definir variable global para el estado de Consecuencias Imprevistas
let consecuenciasImprevistasCompleted = false;

// FunciÃ³n para comprobar el valor de Fluzo - adaptada para valores negativos
function checkFluzoValue() {
    // Si Consecuencias Imprevistas ya estÃ¡ completado, no permitir cambios
    if (consecuenciasImprevistasCompleted) {
        showNotification("Se ha completado Consecuencias Imprevistas. Fluzo condensado estÃ¡ bloqueado.");
        return;
    }

    const valueElement = document.getElementById('fluzo-value');
    if (!valueElement) {
        console.error("Elemento fluzo-value no encontrado");
        return;
    }

    const currentValue = parseInt(valueElement.innerText || '0');
    const totalElement = document.getElementById('fluzo-total');
    const currentTotal = totalElement ? parseInt(totalElement.innerText || '0') : 0;
    
    // Reset del valor en la caja despuÃ©s de comprobar
    const valueToCheck = currentValue;
    valueElement.innerText = '0';
    valueElement.classList.remove('negative'); // Quitar clase visual de negativo
    
    // Calcular el nuevo total (que ahora puede disminuir si valueToCheck es negativo)
    const newTotal = currentTotal + valueToCheck;
    
    // Asegurarse de que no sea un valor negativo en el total
    const finalTotal = Math.max(0, newTotal);
    
    // Determinar mensaje basado en el valor y el ciclo actual
    let message = null;
    if (globalTotals['perdicion_cycle'] === 2) {
        // Plan 1a. Primer avance (ciclo 2)
        if (finalTotal < 78) {
            message = "El valor de fluzo condensado es inferior a la media";
        } else if (finalTotal > 78) {
            message = "El valor de fluzo condensado es superior a la media";
        } else if (finalTotal === 78) {
            message = "Â¡Estas en la media! No alteres mÃ¡s tu valor de fluzo condensado, trata de ayudar a otros grupos colocando pistas en la Reserva temporal";
        }
    } else if (globalTotals['perdicion_cycle'] === 3) {
        // Plan 1a. Segundo avance (ciclo 3)
        if (finalTotal < 81) {
            message = "El valor de fluzo condensado es inferior a la media";
        } else if (finalTotal > 81) {
            message = "El valor de fluzo condensado es superior a la media";
        } else if (finalTotal === 81) {
            message = "Â¡Estas en la media! No alteres mÃ¡s tu valor de fluzo condensado, trata de ayudar a otros grupos colocando pistas en la Reserva temporal";
        }
    }
    
    // Enviar al servidor con el mensaje correspondiente
    sendFluzoCheckResult(finalTotal, valueToCheck, message);
}


// FunciÃ³n para enviar el resultado de la comprobaciÃ³n al servidor
function sendFluzoCheckResult(newTotal, checkedValue, customMessage = null) {
    fetch('/check_fluzo_value/{{ room.id }}/{{ era }}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            total_value: newTotal,
            checked_value: checkedValue,
            custom_message: customMessage
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Error de red: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Actualizar el total con el valor del servidor
            const totalElement = document.getElementById('fluzo-total');
            if (totalElement && data.fluzoTotal !== undefined) {
                totalElement.innerText = data.fluzoTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                totalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    totalElement.classList.remove('highlight-animation');
                }, 1000);
            }
            
            // Si hay un mensaje especial, mostrarlo
            if (data.message) {
                showNotification(data.message);
            }
            
            // Verificar si se ha completado Consecuencias Imprevistas
            if (data.consecuenciasCompleted) {
                consecuenciasImprevistasCompleted = true;
                disableFluzoControls();
            }
        } else if (data.error) {
            // Mostrar error
            showNotification("Error: " + data.error);
        }
    })
    .catch(error => {
        console.error("Error al comprobar fluzo:", error);
        showNotification("Error de conexiÃ³n: No se pudo comprobar el valor de fluzo");
    });
}

// FunciÃ³n para deshabilitar los controles de Fluzo
function disableFluzoControls() {
    const fluzoBlock = document.querySelector('.resource-block:nth-child(3)'); // La tercera columna es Fluzo
    
    if (!fluzoBlock) return;
    
    // Aplicar clase de deshabilitado
    fluzoBlock.classList.add('fluzo-disabled');
    
    // Deshabilitar todos los botones
    const fluzoBtns = fluzoBlock.querySelectorAll('button');
    fluzoBtns.forEach(btn => {
        btn.disabled = true;
        btn.classList.add('disabled');
    });
    
    // Ajustar opacidad del valor
    const fluzoValue = fluzoBlock.querySelector('#fluzo-value');
    if (fluzoValue) {
        fluzoValue.style.opacity = '0.5';
    }
    
    // Agregar mensaje de informativo en el bloque
    const infoMsg = document.createElement('div');
    infoMsg.className = 'consecuencias-completed';
    infoMsg.style.color = '#ff9999';
    infoMsg.style.fontSize = '12px';
    infoMsg.style.textAlign = 'center';
    infoMsg.style.marginTop = '5px';
    infoMsg.textContent = "Consecuencias Imprevistas completado";
    
    // Agregar el mensaje solo si no existe ya
    if (!fluzoBlock.querySelector('.consecuencias-completed')) {
        fluzoBlock.appendChild(infoMsg);
    }
}




// FunciÃ³n mejorada para mostrar una notificaciÃ³n
function showNotification(message) {
    // Crear el elemento de notificaciÃ³n si no existe
    let notification = document.getElementById('game-notification');
    if (!notification) {
        notification = document.createElement('div');
        notification.id = 'game-notification';
        notification.className = 'game-notification';
        
        // Contenido de la notificaciÃ³n
        notification.innerHTML = `
            <div class="notification-content">
                <p></p>
                <button class="notification-btn" onclick="closeNotification()">Aceptar</button>
            </div>
        `;
        
        // Agregar al cuerpo del documento
        document.body.appendChild(notification);
    }
    
    // Actualizar el mensaje
    notification.querySelector('p').innerHTML = message;
    
    // Hacer que aparezca con una animaciÃ³n
    notification.classList.add('show');
}

// FunciÃ³n para cerrar la notificaciÃ³n
function closeNotification() {
    const notification = document.getElementById('game-notification');
    if (notification) {
        notification.classList.remove('show');
    }
}
        
// FunciÃ³n para deshabilitar los controles de PerdiciÃ³n
function disablePerdicionControls() {
    const perdicionPlus = document.querySelector('[onclick="updatePerdicionValue(1)"]');
    const perdicionMinus = document.querySelector('[onclick="updatePerdicionValue(-1)"]');
    const perdicionSend = document.querySelector('[onclick="sendPerdicionValue()"]');
    
    if (perdicionPlus) {
        perdicionPlus.disabled = true;
        perdicionPlus.classList.add('disabled');
    }
    if (perdicionMinus) {
        perdicionMinus.disabled = true;
        perdicionMinus.classList.add('disabled');
    }
    if (perdicionSend) {
        perdicionSend.disabled = true;
        perdicionSend.classList.add('disabled');
    }
}

// FunciÃ³n para habilitar los controles de PerdiciÃ³n
function enablePerdicionControls() {
    const perdicionPlus = document.querySelector('[onclick="updatePerdicionValue(1)"]');
    const perdicionMinus = document.querySelector('[onclick="updatePerdicionValue(-1)"]');
    const perdicionSend = document.querySelector('[onclick="sendPerdicionValue()"]');
    
    if (perdicionPlus) {
        perdicionPlus.disabled = false;
        perdicionPlus.classList.remove('disabled');
    }
    if (perdicionMinus) {
        perdicionMinus.disabled = false;
        perdicionMinus.classList.remove('disabled');
    }
    if (perdicionSend) {
        perdicionSend.disabled = false;
        perdicionSend.classList.remove('disabled');
    }
}

// FunciÃ³n actualizada para manejar la desactivaciÃ³n del botÃ³n de Biff
function updateBiffButton(defeats, disableButton = false) {
    const biffButton = document.getElementById('biff-button');
    if (!biffButton) return;
    
    let text = "";
    if (defeats === 0) {
        text = "Sin derrotas";
    } else if (defeats === 1) {
        text = "Derrotado 1 vez";
    } else {
        text = `Derrotado ${defeats} veces`;
    }
    
    biffButton.textContent = text;
    
    // Aplicar animaciÃ³n de resaltado
    biffButton.classList.add('highlight-animation');
    
    // Eliminar la animaciÃ³n despuÃ©s de que termine
    setTimeout(() => {
        biffButton.classList.remove('highlight-animation');
    }, 1000);
    
    // Desactivar el botÃ³n si es necesario
    if (disableButton) {
        biffButton.disabled = true;
        biffButton.classList.add('disabled');
        biffButton.style.opacity = '0.5';
        biffButton.style.cursor = 'not-allowed';
        biffButton.title = 'Biff Tannen ha sido aÃ±adido a la zona de victoria';
    }
}

// FunciÃ³n actualizada para derrotar a Biff
function defeatBiff() {
    fetch('/biff_defeat/{{ room.id }}/{{ era }}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({})  // Enviar un objeto vacÃ­o para asegurar formato correcto
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Error de red: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            updateBiffButton(data.defeats, data.disable_button);
            console.log("Biff ha sido derrotado", data.defeats, "veces");
            
            // Mostrar el mensaje de Biff si existe
            if (data.message) {
                showNotification(data.message);
            }
        } else {
            console.error("Error al actualizar las derrotas de Biff:", data.error);
            showNotification("Error: " + (data.error || "No se pudo actualizar las derrotas de Biff"));
        }
    })
    .catch(error => {
        console.error("Error en la solicitud:", error);
        showNotification("Error de conexiÃ³n al actualizar las derrotas de Biff");
    });
}

// FunciÃ³n mejorada para resetear los anuncios
function resetAnnouncements() {
    if (!confirm("Â¿EstÃ¡s seguro de que deseas resetear TODOS los anuncios de esta era?")) {
        return;
    }
    
    fetch('/reset_announcements/{{ room.id }}/{{ era }}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Recargar la pÃ¡gina inmediatamente para mostrar cambios
            window.location.reload();
        } else {
            alert("Error: " + data.error);
        }
    })
    .catch(error => {
        console.error("Error:", error);
        alert("Ha ocurrido un error al resetear los anuncios.");
    });
}

// FunciÃ³n mejorada para resetear las derrotas de Biff
function resetBiff() {
    if (!confirm("Â¿EstÃ¡s seguro de que deseas resetear el contador de derrotas de Biff?")) {
        return;
    }
    
    fetch('/reset_biff/{{ room.id }}/{{ era }}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Recargar la pÃ¡gina inmediatamente para mostrar cambios
            window.location.reload();
        } else {
            alert("Error: " + data.error);
        }
    })
    .catch(error => {
        console.error("Error:", error);
        alert("Ha ocurrido un error al resetear el contador de Biff.");
    });
}

// FunciÃ³n mejorada para resetear un contador de columna especÃ­fico
function resetColumn(column) {
    if (!confirm(`Â¿EstÃ¡s seguro de que deseas resetear el contador de ${column}?`)) {
        return;
    }
    
    fetch(`/reset_column/{{ room.id }}/${column}`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Recargar la pÃ¡gina inmediatamente para mostrar cambios
            window.location.reload();
        } else {
            alert("Error: " + data.error);
        }
    })
    .catch(error => {
        console.error("Error:", error);
        alert(`Ha ocurrido un error al resetear el contador de ${column}.`);
    });
}

document.addEventListener('DOMContentLoaded', function() {
    // Inicializar Socket.IO
    const socket = io();
    
    // Variables para almacenar el estado actual
    const currentRoom = {{ room.id }};
    const currentEra = "{{ era }}";
    
    // Unirse a la sala correspondiente
    socket.emit('join', { room: `room_${currentRoom}` });
    
    // Verificar el estado inicial de Fluzo basado en el ciclo de perdiciÃ³n
    const initialPerdicionCycle = {{ perdicion_cycle }};
    toggleFluzoBasedOnCycle(initialPerdicionCycle, true); // true indica que es carga inicial

    // Verificar si el botÃ³n de Biff ya estÃ¡ desactivado
    const biffButton = document.getElementById('biff-button');
    if (biffButton && biffButton.classList.contains('disabled')) {
        biffButton.disabled = true;
        biffButton.style.opacity = '0.5';
        biffButton.style.cursor = 'not-allowed';
        biffButton.title = 'Biff Tannen ha sido aÃ±adido a la zona de victoria';
    }

    
    // ========== EVENTOS PARA PERDICIÃ“N ==========
    
    // Evento de actualizaciÃ³n de perdiciÃ³n
    socket.on('perdicion_update', function(data) {
        // Verificar que la actualizaciÃ³n sea para nuestra sala y era
        if (data.room_id === currentRoom && data.era === currentEra) {
            // Actualizar el total local
            const totalElement = document.getElementById('perdicion-total');
            if (totalElement) {
                totalElement.innerText = data.columnTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                totalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    totalElement.classList.remove('highlight-animation');
                }, 1000);
            }
            
            // Actualizar el ciclo si estÃ¡ presente
            if (data.perdicionCycle) {
                updatePerdicionCycle(data.perdicionCycle);
            }
            
            // Mostrar notificaciÃ³n si existe
            if (data.notification) {
                showNotification(data.notification);
            }
        }
    });
    
    // Evento de actualizaciÃ³n global de perdiciÃ³n
    socket.on('global_perdicion_update', function(data) {
        // Actualizar el total global
        const globalElement = document.getElementById('perdicion-global');
        if (globalElement) {
            globalTotals['perdicion'] = data.globalTotal;
            globalElement.innerText = data.globalTotal;
            
            // AÃ±adir animaciÃ³n de resaltado
            globalElement.classList.add('highlight-animation');
            
            // Eliminar la animaciÃ³n despuÃ©s de que termine
            setTimeout(() => {
                globalElement.classList.remove('highlight-animation');
            }, 1000);
        }
        
        // Actualizar el ciclo si estÃ¡ presente
        if (data.perdicionCycle) {
            updatePerdicionCycle(data.perdicionCycle);
        }
        
        // Mostrar notificaciÃ³n si existe
        if (data.notification) {
            showNotification(data.notification);
        }
    });
    
    // Evento de completado de ciclo de perdiciÃ³n (afecta a todos los clientes)
    socket.on('perdicion_cycle_completed', function(data) {
        console.log("Â¡Se ha completado un ciclo de perdiciÃ³n!", data);
        
        // Reiniciar el contador de "perdiciÃ³n" en la interfaz actual
        const perdicionTotalElement = document.getElementById('perdicion-total');
        if (perdicionTotalElement) {
            perdicionTotalElement.innerText = '0';
            perdicionTotalElement.classList.add('highlight-animation');
            
            // Eliminar la animaciÃ³n despuÃ©s de que termine
            setTimeout(() => {
                perdicionTotalElement.classList.remove('highlight-animation');
            }, 1000);
        }
        
        // Actualizar el ciclo de perdiciÃ³n
        updatePerdicionCycle(data.perdicionCycle);
        
        // Actualizar el contador global a 0
        const globalElement = document.getElementById('perdicion-global');
        if (globalElement) {
            globalTotals['perdicion'] = 0;
            globalElement.innerText = '0';
            
            // AÃ±adir animaciÃ³n de resaltado
            globalElement.classList.add('highlight-animation');
            
            // Eliminar la animaciÃ³n despuÃ©s de que termine
            setTimeout(() => {
                globalElement.classList.remove('highlight-animation');
            }, 1000);
        }
        
        // Mostrar notificaciÃ³n solo en la era y sala donde se originÃ³ el evento
        if (currentRoom === data.originRoom && currentEra === data.originEra && data.notification) {
            showNotification(data.notification);
        }
        
        // Si estamos pasando al ciclo 3, mostrar la notificaciÃ³n de Fluzo modificado
        if (data.perdicionCycle === 3) {
            showNotification("El nivel de Fluzo condensado ha sido alterado");
        }
    });
    
    // ========== EVENTOS PARA RESERVA ==========
    
    // Evento de actualizaciÃ³n de reserva
    socket.on('reserva_update', function(data) {
        // Verificar que la actualizaciÃ³n sea para nuestra sala y era
        if (data.room_id === currentRoom && data.era === currentEra) {
            // Actualizar el total local
            const totalElement = document.getElementById('reserva-total');
            if (totalElement) {
                totalElement.innerText = data.columnTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                totalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    totalElement.classList.remove('highlight-animation');
                }, 1000);
            }
        }
    });
    
    // Evento de actualizaciÃ³n global de reserva
    socket.on('global_reserva_update', function(data) {
        // Actualizar el total global
        const globalElement = document.getElementById('reserva-global');
        if (globalElement) {
            globalTotals['reserva'] = data.globalTotal;
            globalElement.innerText = data.globalTotal;
            
            // AÃ±adir animaciÃ³n de resaltado
            globalElement.classList.add('highlight-animation');
            
            // Eliminar la animaciÃ³n despuÃ©s de que termine
            setTimeout(() => {
                globalElement.classList.remove('highlight-animation');
            }, 1000);
        }
    });
    
    // ========== EVENTOS PARA FLUZO ==========
    
    // Evento de actualizaciÃ³n de fluzo
    socket.on('fluzo_update', function(data) {
        // Verificar que la actualizaciÃ³n sea para nuestra sala y era
        if (data.room_id === currentRoom && data.era === currentEra) {
            console.log("Recibido evento de actualizaciÃ³n de fluzo", data);
            
            // Actualizar el valor en pantalla (la caja)
            const valueElement = document.getElementById('fluzo-value');
            if (valueElement && data.fluzoValue !== undefined) {
                valueElement.innerText = data.fluzoValue;
            }
            
            // Actualizar el total acumulado
            const totalElement = document.getElementById('fluzo-total');
            if (totalElement && data.fluzoTotal !== undefined) {
                totalElement.innerText = data.fluzoTotal;
                
                // AÃ±adir animaciÃ³n de resaltado
                totalElement.classList.add('highlight-animation');
                
                // Eliminar la animaciÃ³n despuÃ©s de que termine
                setTimeout(() => {
                    totalElement.classList.remove('highlight-animation');
                }, 1000);
            }
            
            // Verificar el estado de Consecuencias Imprevistas
            if (data.consecuenciasCompleted) {
                consecuenciasImprevistasCompleted = true;
                disableFluzoControls();
            }
            
            // Si hay un mensaje y NO estamos en modo silencioso, mostrarlo
            if (data.message && !data.silent) {
                showNotification(data.message);
            }
            // Si es un valor aleatorio, NO mostrar la notificaciÃ³n si estÃ¡ marcado como silencioso
            else if (data.isRandomValue && !data.silent) {
                //showNotification(`Â¡La energÃ­a de Fluzo condensado se ha estabilizado en ${data.fluzoTotal}!`);
            }
        }
    });
    
    // ========== EVENTOS PARA CONSECUENCIAS IMPREVISTAS ==========
    
    // Evento cuando se completa Consecuencias Imprevistas (se enviarÃ¡ a todos los clientes)
    socket.on('consecuencias_imprevistas_completed', function(data) {
        console.log("Recibido evento de Consecuencias Imprevistas completado", data);
        
        // Actualizar el estado global
        consecuenciasImprevistasCompleted = true;
        
        // Deshabilitar controles de Fluzo
        disableFluzoControls();
        
        // Mostrar notificaciÃ³n
        if (data.message) {
            showNotification(data.message);
        }
    });

    // ========== OTROS EVENTOS ==========
    
    // Escuchar eventos de reinicio del servidor
    socket.on('server_reset', function(data) {
        alert(data.message);
        window.location.reload();
    });
    
    // Escuchar eventos de actualizaciÃ³n de botones
    socket.on('button_update', function(data) {
        // Verificar que la actualizaciÃ³n sea para nuestra sala
        if (data.room_id === currentRoom) {
            console.log("Recibido evento de actualizaciÃ³n de botones", data);
            
            // Si estamos en la misma era del botÃ³n que cambiÃ³, actualizamos la UI
            if (currentEra === data.era) {
                // Actualizar el estado del botÃ³n que cambiÃ³
                const buttonForm = document.getElementById(`form-button-${data.button_idx}`);
                if (buttonForm) {
                    const buttonElement = buttonForm.querySelector('button');
                    if (data.is_activating) {
                        // Si se estÃ¡ activando
                        buttonElement.classList.add('active');
                        if (!buttonElement.querySelector('.status-badge')) {
                            // Agregar la etiqueta de "Completado" si no existe
                            const badge = document.createElement('span');
                            badge.className = 'status-badge';
                            badge.textContent = 'Completado';
                            buttonElement.appendChild(badge);
                        }
                    } else {
                        // Si se estÃ¡ desactivando
                        buttonElement.classList.remove('active');
                        const badge = buttonElement.querySelector('.status-badge');
                        if (badge) {
                            badge.remove();
                        }
                    }
                }
            }
            
            // Actualizar el estado de todos los botones segÃºn las dependencias
            // para reflejar quÃ© botones estÃ¡n disponibles
            for (const era in data.available_buttons) {
                if (era === currentEra) {
                    // Actualizar los botones de la era actual
                    data.available_buttons[era].forEach((isAvailable, idx) => {
                        const buttonForm = document.getElementById(`form-button-${idx}`);
                        if (buttonForm) {
                            const buttonElement = buttonForm.querySelector('button');
                            
                            // Primero eliminamos todas las clases de estado
                            buttonElement.classList.remove('available', 'disabled');
                            
                            // Verificar si estÃ¡ activo segÃºn el progress actualizado
                            const isActive = data.progress[era][idx];
                            
                            if (isActive) {
                                buttonElement.classList.add('active');
                                if (!buttonElement.querySelector('.status-badge')) {
                                    const badge = document.createElement('span');
                                    badge.className = 'status-badge';
                                    badge.textContent = 'Completado';
                                    buttonElement.appendChild(badge);
                                }
                            } else {
                                buttonElement.classList.remove('active');
                                const badge = buttonElement.querySelector('.status-badge');
                                if (badge) {
                                    badge.remove();
                                }
                                
                                // Si no estÃ¡ activo, determinar si estÃ¡ disponible o deshabilitado
                                if (isAvailable) {
                                    buttonElement.classList.add('available');
                                    buttonElement.disabled = false;
                                } else {
                                    buttonElement.classList.add('disabled');
                                    buttonElement.disabled = true;
                                }
                            }
                        }
                    });
                }
            }
        }
    });
    
    // Escuchar eventos de actualizaciÃ³n de Biff
        socket.on('biff_update', function(data) {
        // Verificar que la actualizaciÃ³n sea para nuestra sala y era
        if (data.room_id === currentRoom && data.era === currentEra) {
            updateBiffButton(data.defeats, data.disable_button);
        
            // Mostrar el mensaje de Biff si existe
            if (data.message) {
                showNotification(data.message);
            }
        }
    });
    
    // ========== CARGA INICIAL DE DATOS ==========
    
    // Obtener datos iniciales de columnas del servidor cuando se carga la pÃ¡gina
    fetch('/get_column_totals/' + currentRoom + '/' + currentEra, {
        method: 'GET',
        headers: {
            'Content-Type': 'application/json',
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Error de red: ' + response.status);
        }
        return response.json();
    })
    .then(data => {
        if (data.success) {
            // Actualizar totales de columnas con datos del servidor
            if (data.columnTotals) {
                // Actualizar perdiciÃ³n
                const perdicionTotalElement = document.getElementById('perdicion-total');
                if (perdicionTotalElement && data.columnTotals.perdicion !== undefined) {
                    perdicionTotalElement.innerText = data.columnTotals.perdicion;
                }
                
                // Actualizar reserva
                const reservaTotalElement = document.getElementById('reserva-total');
                if (reservaTotalElement && data.columnTotals.reserva !== undefined) {
                    reservaTotalElement.innerText = data.columnTotals.reserva;
                }
                
                // Actualizar fluzo si existe
                const fluzoTotalElement = document.getElementById('fluzo-total');
                if (fluzoTotalElement && data.columnTotals.fluzo !== undefined) {
                    fluzoTotalElement.innerText = data.columnTotals.fluzo;
                }
            }
            
            // Actualizar los contadores globales
            if (data.globalTotals) {
                // Actualizar perdiciÃ³n global
                const perdicionGlobalElement = document.getElementById('perdicion-global');
                if (perdicionGlobalElement && data.globalTotals.perdicion !== undefined) {
                    globalTotals['perdicion'] = data.globalTotals.perdicion;
                    perdicionGlobalElement.innerText = data.globalTotals.perdicion;
                }
                
                // Actualizar reserva global
                const reservaGlobalElement = document.getElementById('reserva-global');
                if (reservaGlobalElement && data.globalTotals.reserva !== undefined) {
                    globalTotals['reserva'] = data.globalTotals.reserva;
                    reservaGlobalElement.innerText = data.globalTotals.reserva;
                }
                
                // Actualizar ciclo de perdiciÃ³n
                if (data.globalTotals.perdicion_cycle !== undefined) {
                    globalTotals['perdicion_cycle'] = data.globalTotals.perdicion_cycle;
                    updatePerdicionCycle(data.globalTotals.perdicion_cycle);
                }
            }
        }
    })
    .catch(error => {
        console.error("Error al obtener totales de columna:", error);
    });

    // Verificar si Consecuencias Imprevistas ya estÃ¡ completado
    function checkConsecuenciasImprevistasStatus() {
        fetch('/get_global_counters', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            }
        })
        .then(response => {
            if (!response.ok) {
                throw new Error('Error de red: ' + response.status);
            }
            return response.json();
        })
        .then(data => {
            if (data.success && data.globalTotals) {
                // Actualizar el estado de Consecuencias Imprevistas
                if (data.globalTotals.consecuencias_imprevistas) {
                    consecuenciasImprevistasCompleted = true;
                    disableFluzoControls();
                }
            }
        })
        .catch(error => {
            console.error("Error al obtener estado de Consecuencias Imprevistas:", error);
        });
    }
    
    // Verificar el estado de Consecuencias Imprevistas al cargar la pÃ¡gina
    checkConsecuenciasImprevistasStatus();
    
    // Verificar si estamos en el ciclo 4 (despuÃ©s del tercer ciclo) al cargar
    const perdicionCycle = {{ perdicion_cycle }};
    if (perdicionCycle > 3) {
        disablePerdicionControls();
    }

    // ========== EVENTOS PARA LAS CONDICIONES DE VICTORIA ==========
    
    // Escuchar el evento de condiciones de victoria cumplidas
    socket.on('victory_conditions_met', function(data) {
        console.log("Â¡Se han cumplido las condiciones de victoria!", data);
        
        // Mostrar notificaciÃ³n especial
        if (data.message) {
            // Crear un estilo especial para la notificaciÃ³n de victoria
            const victoryNotification = document.createElement('div');
            victoryNotification.id = 'victory-notification';
            victoryNotification.className = 'game-notification show';
            victoryNotification.style.zIndex = '2000'; // Mayor que la notificaciÃ³n normal
            
            // Contenido de la notificaciÃ³n con estilo especial
            victoryNotification.innerHTML = `
                <div class="notification-content" style="background-color: rgba(30, 20, 10, 0.95); border: 3px solid #ffd700; box-shadow: 0 0 40px rgba(255, 215, 0, 0.8);">
                    <p style="color: #ffd700; font-size: 32px; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);">${data.message}</p>
                    <button class="notification-btn" style="background-color: #443311; color: #ffd700; border-color: #ffd700; font-size: 18px;" onclick="closeVictoryNotification()">Â¡Entendido!</button>
                </div>
            `;
            
            // Agregar al cuerpo del documento, reemplazando cualquier notificaciÃ³n de victoria existente
            const existingVictory = document.getElementById('victory-notification');
            if (existingVictory) {
                existingVictory.remove();
            }
            document.body.appendChild(victoryNotification);
            
            // AÃ±adir vibraciones sutiles a la notificaciÃ³n para llamar mÃ¡s la atenciÃ³n
            animateVictoryNotification();
        }
    });
    
    // FunciÃ³n para animar la notificaciÃ³n de victoria
    function animateVictoryNotification() {
        const notification = document.getElementById('victory-notification');
        if (!notification) return;
        
        const content = notification.querySelector('.notification-content');
        if (!content) return;
        
        // Crear el efecto de brillo radiante
        content.style.transition = 'box-shadow 1s ease-in-out';
        
        let glowIntensity = 0;
        let growing = true;
        
        const glowAnimation = setInterval(() => {
            if (growing) {
                glowIntensity += 2;
                if (glowIntensity >= 40) growing = false;
            } else {
                glowIntensity -= 2;
                if (glowIntensity <= 10) growing = true;
            }
            
            content.style.boxShadow = `0 0 ${glowIntensity}px rgba(255, 215, 0, 0.8)`;
            
            // Verificar si la notificaciÃ³n sigue existiendo
            if (!document.getElementById('victory-notification')) {
                clearInterval(glowAnimation);
            }
        }, 100);
    }
    
    // FunciÃ³n para cerrar la notificaciÃ³n de victoria
    function closeVictoryNotification() {
        const notification = document.getElementById('victory-notification');
        if (notification) {
            notification.classList.remove('show');
            // Remover despuÃ©s de la animaciÃ³n
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300);
        }
    }

    // ========== MODAL DE PREPARACIÃ“N CON NAVEGACIÃ“N DE IMÃGENES ==========
    
    // Elementos del DOM
    const prepModal = document.getElementById('prep-modal');
    const prepButton = document.getElementById('prep-button');
    const closeModal = document.querySelector('.close-modal');
    const prevButton = document.getElementById('prev-image');
    const nextButton = document.getElementById('next-image');
    const imageCounter = document.getElementById('image-counter');
    
    // Variables para la navegaciÃ³n
    let currentImageIndex = 0;
    let prepImages = [];
    
    // FunciÃ³n para inicializar las imÃ¡genes y contadores
    function initializeImageNavigation() {
        // Seleccionar todas las imÃ¡genes disponibles
        prepImages = document.querySelectorAll('.prep-image');
        const totalImages = prepImages.length;
        
        // Actualizar el contador inicial
        if (imageCounter) {
            imageCounter.textContent = `1 / ${totalImages}`;
        }
        
        // Deshabilitar el botÃ³n anterior inicialmente (estamos en la primera imagen)
        if (prevButton) {
            prevButton.disabled = true;
        }
        
        // Deshabilitar el botÃ³n siguiente si solo hay una imagen
        if (nextButton) {
            nextButton.disabled = totalImages <= 1;
        }
    }
    
    // FunciÃ³n para actualizar la imagen visible
    function updateImage() {
        const totalImages = prepImages.length;
        
        // Ocultar todas las imÃ¡genes
        prepImages.forEach(img => img.classList.remove('active'));
        
        // Mostrar la imagen actual
        if (prepImages[currentImageIndex]) {
            prepImages[currentImageIndex].classList.add('active');
        }
        
        // Actualizar el contador
        if (imageCounter) {
            imageCounter.textContent = `${currentImageIndex + 1} / ${totalImages}`;
        }
        
        // Habilitar/deshabilitar botones segÃºn la posiciÃ³n
        if (prevButton) {
            prevButton.disabled = currentImageIndex === 0;
        }
        if (nextButton) {
            nextButton.disabled = currentImageIndex === totalImages - 1;
        }
    }
    
    // Evento para imagen anterior
    if (prevButton) {
        prevButton.addEventListener('click', function() {
            if (currentImageIndex > 0) {
                currentImageIndex--;
                updateImage();
            }
        });
    }
    
    // Evento para imagen siguiente
    if (nextButton) {
        nextButton.addEventListener('click', function() {
            if (prepImages && currentImageIndex < prepImages.length - 1) {
                currentImageIndex++;
                updateImage();
            }
        });
    }
    
    // Abrir el modal cuando se hace clic en el botÃ³n
    if (prepButton) {
        prepButton.addEventListener('click', function() {
            prepModal.style.display = 'block';
            document.body.style.overflow = 'hidden'; // Evitar scroll
            
            // Inicializar la navegaciÃ³n y mostrar la primera imagen
            currentImageIndex = 0;
            initializeImageNavigation();
            updateImage();
        });
    }
    
    // Cerrar el modal cuando se hace clic en la X
    if (closeModal) {
        closeModal.addEventListener('click', function() {
            prepModal.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restaurar scroll
        });
    }
    
    // Cerrar el modal si se hace clic fuera de Ã©l
    window.addEventListener('click', function(event) {
        if (event.target === prepModal) {
            prepModal.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restaurar scroll
        }
    });
    
    // AÃ±adir evento para tecla Escape y navegaciÃ³n con flechas
    window.addEventListener('keydown', function(event) {
        if (prepModal && prepModal.style.display === 'block') {
            if (event.key === 'Escape') {
                prepModal.style.display = 'none';
                document.body.style.overflow = 'auto'; // Restaurar scroll
            } else if (event.key === 'ArrowLeft' && currentImageIndex > 0) {
                currentImageIndex--;
                updateImage();
            } else if (event.key === 'ArrowRight' && prepImages && currentImageIndex < prepImages.length - 1) {
                currentImageIndex++;
                updateImage();
            }
        }
    });
});

// AÃ±adir la nueva funciÃ³n closeVictoryNotification al bloque <script> si no estÃ¡ incluida en el cÃ³digo JavaScript anterior
function closeVictoryNotification() {
    const notification = document.getElementById('victory-notification');
    if (notification) {
        notification.classList.remove('show');
        // Remover despuÃ©s de la animaciÃ³n
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 300);
    }
}

</script>
</head>
<body>
    <div class="content-wrapper">
        {% if is_admin %}
            <div class="admin-badge">MODO ADMINISTRADOR</div>
            <a href="{{ url_for('game.room', room_id=room.id) }}" class="back-link">â† Volver al Grupo</a>
        {% else %}
            {% if mesa_name %}
                <div class="mesa-badge">{{ mesa_name }}</div>
            {% endif %}
            <a href="{{ url_for('auth.logout') }}" class="back-link">â† Cerrar sesiÃ³n</a>
        {% endif %}
        
        <h1 style="display: flex; justify-content: center; align-items: center; gap: 15px;">
    {% if mesa_name %}
        <span>{{ mesa_name }} - {{ era|capitalize }}</span>
    {% else %}
        <span>{{ room.name }} - {{ era|capitalize }}</span>
    {% endif %}
    <button id="prep-button" class="prep-button">PreparaciÃ³n</button>
</h1>

<!-- Modal para la imagen de preparaciÃ³n con imÃ¡genes especÃ­ficas por era -->
<div id="prep-modal" class="prep-modal">
    <div class="prep-modal-content">
        <span class="close-modal">&times;</span>
        <h2>PreparaciÃ³n - {{ era|capitalize }}</h2>
        <div class="image-container">
            {% if era == "pasado" %}
                <!-- ImÃ¡genes para la era Pasado -->
                <img src="{{ url_for('static', filename='images/preparacion_base.jpg') }}" alt="PreparaciÃ³n Pasado 1" class="prep-image active">
                <img src="{{ url_for('static', filename='images/preparacion_pasado.jpg') }}" alt="PreparaciÃ³n Pasado 2" class="prep-image">
            {% elif era == "presente" %}
                <!-- ImÃ¡genes para la era Presente -->
                <img src="{{ url_for('static', filename='images/preparacion_base.jpg') }}" alt="PreparaciÃ³n Presente 1" class="prep-image active">
                <img src="{{ url_for('static', filename='images/preparacion_presente.jpg') }}" alt="PreparaciÃ³n Presente 2" class="prep-image">
            {% else %}
                <!-- ImÃ¡genes para la era Futuro -->
                <img src="{{ url_for('static', filename='images/preparacion_base.jpg') }}" alt="PreparaciÃ³n Futuro 1" class="prep-image active">
                <img src="{{ url_for('static', filename='images/preparacion_futuro.jpg') }}" alt="PreparaciÃ³n Futuro 2" class="prep-image">
            {% endif %}
        </div>
        <div class="image-navigation">
            <button id="prev-image" class="nav-button">&lt; Anterior</button>
            <span id="image-counter">1 / 2</span>
            <button id="next-image" class="nav-button">Siguiente &gt;</button>
        </div>
    </div>
</div>

	<!-- SECCIÃ“N DE ANUNCIOS -->
    <div class="section-container">
        <div class="section-title">Anuncios</div>
        {% if is_admin %}
        <div class="reset-buttons-container">
            <button class="reset-button" onclick="resetAnnouncements()">Resetear Anuncios</button>
        </div>
        {% endif %}
        <div class="announcements-grid era-{{ era }}">
            {% for i in range(button_info|length) %}
                <form id="form-button-{{ i }}" action="{{ url_for('game.toggle_button', room_id=room.id, era=era, button_idx=i) }}" method="post" onsubmit="return confirmDemarking({{ i }}, {{ progress[era][i]|tojson }});">
                    <button 
                        type="submit"
                        class="game-button button-{{ era }}-{{ i }} 
                               {% if progress[era][i] %}active{% endif %} 
                               {% if not progress[era][i] and available_buttons[i] %}available{% endif %}
                               {% if not available_buttons[i] and not progress[era][i] %}disabled{% endif %}"
                        {% if not available_buttons[i] and not progress[era][i] %}disabled{% endif %}
                    >
                        <div style="width: 100%; padding-bottom: 20px;">{{ button_info[i] }}</div>
                        {% if progress[era][i] %}
                            <span class="status-badge">Completado</span>
                        {% endif %}
                    </button>
                </form>
            {% endfor %}
        </div>
    </div>
<!-- SECCIÃ“N DE BIFF TANNEN -->
    <div class="section-container">
        <div class="section-title">Derrotas de Biff Tannen</div>
        {% if is_admin %}
        <div class="reset-buttons-container">
            <button class="reset-button" onclick="resetBiff()">Resetear Biff</button>
        </div>
        {% endif %}
        <div class="biff-button-container">
            <button 
                id="biff-button"
                onclick="defeatBiff()"
                class="biff-button {% if biff_disabled %}disabled{% endif %}"
                {% if biff_disabled %}disabled{% endif %}
                {% if biff_disabled %}title="Biff Tannen ha sido aÃ±adido a la zona de victoria"{% endif %}
            >
                {% if biff_defeats == 0 %}
                    Sin derrotas
                {% elif biff_defeats == 1 %}
                    Derrotado 1 vez
                {% else %}
                    Derrotado {{ biff_defeats }} veces
                {% endif %}
            </button>
        </div>
    </div>
<!-- SECCIÃ“N DE RECURSOS con funciones separadas -->
    <div class="section-container">
        {% if is_admin %}
        <div class="reset-buttons-container">
            <button class="reset-button" onclick="resetColumn('perdicion')">Resetear PerdiciÃ³n</button>
            <button class="reset-button" onclick="resetColumn('reserva')">Resetear Reserva</button>
        </div>
        {% endif %}
        
        <div class="section-title">Contadores</div>
        
        <div class="resources-flex">
            <!-- PerdiciÃ³n -->
            <div class="resource-block">
                <h3>PerdiciÃ³n</h3>
                <div id="perdicion-cycle" class="cycle-indicator">
                {% if perdicion_cycle == 1 %}
                    Plan 1a
                {% elif perdicion_cycle == 2 %}
                    Plan 1a. Primer avance
                {% elif perdicion_cycle == 3 %}
                    Plan 1a. Segundo avance
                {% else %}
                    FIN
                {% endif %}
                </div>

                <button class="btn-plus {% if perdicion_cycle > 3 %}disabled{% endif %}" onclick="updatePerdicionValue(1)" {% if perdicion_cycle > 3 %}disabled{% endif %}>+</button>
                <div id="perdicion-value" class="value-display">0</div>
                <button class="btn-minus {% if perdicion_cycle > 3 %}disabled{% endif %}" onclick="updatePerdicionValue(-1)" {% if perdicion_cycle > 3 %}disabled{% endif %}>âˆ’</button>
                <button class="btn-send {% if perdicion_cycle > 3 %}disabled{% endif %}" onclick="sendPerdicionValue()" {% if perdicion_cycle > 3 %}disabled{% endif %}>Enviar</button>
                <div class="total-display">
                    <span>Enviado: </span><span id="perdicion-total">{{ column_totals.perdicion if column_totals else 0 }}</span>
                </div>
                <div class="global-display">
                    <span>Global: </span><span id="perdicion-global">0</span>
                </div>
            </div>
            
            <!-- Reserva -->
            <div class="resource-block">
                <h3>Reserva</h3>
                <button class="btn-plus" onclick="updateReservaValue(1)">+</button>
                <div id="reserva-value" class="value-display">0</div>
                <button class="btn-minus" onclick="updateReservaValue(-1)">âˆ’</button>
                <button class="btn-send" onclick="sendReservaValue()">Enviar</button>
                <div class="total-display">
                    <span>Enviado: </span><span id="reserva-total">{{ column_totals.reserva if column_totals else 0 }}</span>
                </div>
                <div class="global-display">
                    <span>Global: </span><span id="reserva-global">0</span>
                </div>
            </div>
            
<!-- Fluzo -->
<div class="resource-block {% if perdicion_cycle == 1 %}fluzo-disabled{% endif %}">
    <h3>Fluzo condensado</h3>
    <div style="display: flex; justify-content: center; margin-bottom: 5px;">
        <button class="btn-plus {% if perdicion_cycle == 1 %}disabled{% endif %}" 
                onclick="updateFluzoValue(1)" 
                {% if perdicion_cycle == 1 %}disabled{% endif %}
                style="width: 40px; margin: 0 5px;">+1</button>
                
        <button class="btn-plus {% if perdicion_cycle == 1 %}disabled{% endif %}" 
                onclick="updateFluzoValue(5)" 
                {% if perdicion_cycle == 1 %}disabled{% endif %}
                style="width: 40px; margin: 0 5px;">+5</button>
    </div>
    
    <div id="fluzo-value" class="value-display" style="margin: 5px auto; {% if perdicion_cycle == 1 %}opacity: 0.5;{% endif %}">0</div>
    
    <div style="display: flex; justify-content: center; margin-top: 5px;">
        <button class="btn-minus {% if perdicion_cycle == 1 %}disabled{% endif %}" 
                onclick="updateFluzoValue(-1)" 
                {% if perdicion_cycle == 1 %}disabled{% endif %}
                style="width: 40px; margin: 0 5px;">-1</button>
                
        <button class="btn-minus {% if perdicion_cycle == 1 %}disabled{% endif %}" 
                onclick="updateFluzoValue(-5)" 
                {% if perdicion_cycle == 1 %}disabled{% endif %}
                style="width: 40px; margin: 0 5px;">-5</button>
    </div>
    
    <!-- BotÃ³n Comprobar -->
    <button class="btn-send {% if perdicion_cycle == 1 %}disabled{% endif %}" 
            onclick="checkFluzoValue()" 
            {% if perdicion_cycle == 1 %}disabled{% endif %}
            style="margin-top: 10px;">Comprobar</button>
    
    <div class="total-display">
        <span>Valor: </span><span id="fluzo-total">{{ column_totals.fluzo if column_totals else 0 }}</span>
    </div>
</div>
</div>
</div>
<!-- NotificaciÃ³n con botÃ³n de Aceptar funcional -->
    <div id="game-notification" class="game-notification">
        <div class="notification-content">
            <p></p>
            <button class="notification-btn" onclick="closeNotification()">Aceptar</button>
        </div>
    </div>
<!-- NotificaciÃ³n de victoria con animaciÃ³n -->
<div id="victory-notification" class="game-notification">
    <div class="notification-content">
        <p>->R1</p>
        <button class="notification-btn" onclick="closeVictoryNotification()">Â¡Entendido!</button>
    </div>
</div>

</body>
</html>


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\views\templates\login.html
--------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arkham Horror - 2Âº Aniversario de Ignota Alicante</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=EB+Garamond&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'EB Garamond', serif;
            margin: 0;
            padding: 15px;
            background-color: #0a0a0a;
            background-image: url('https://i.postimg.cc/8PGqXKYC/borja-pindado-ah-walkingthroughtime-borjapindado-1.jpg');
            background-position: center center;
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            color: #d4c8a8;
            text-align: center;
            min-height: 100vh;
        }
        .content-wrapper {
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        .welcome-title {
            font-family: 'Cinzel', serif;
            font-size: 28px;
            font-weight: bold;
            color: #c0a062;
            margin: 20px 0 15px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            letter-spacing: 2px;
        }
        .welcome-subtitle {
            font-size: 22px;
            color: #a89c8a;
            margin-bottom: 20px;
            font-style: italic;
        }
        .arkham-logo {
            max-width: 200px;
            margin: 20px auto;
            filter: sepia(0.5) brightness(0.9);
        }
        .login-form {
            max-width: 350px;
            margin: 0 auto;
            padding: 20px;
        }
        .form-group {
            margin-bottom: 25px;
        }
        .input-field {
            width: 100%;
            padding: 12px;
            border-radius: 5px;
            background-color: rgba(30, 24, 18, 0.9);
            border: 1px solid #5a4526;
            color: #c0a062;
            font-family: 'EB Garamond', serif;
            font-size: 16px;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }
        .submit-button {
            padding: 12px 25px;
            background-color: #3d2e16;
            color: #c0a062;
            border: 1px solid #5a4526;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        .submit-button:hover {
            background-color: #5a4526;
            transform: translateY(-2px);
        }
        .error-message {
            background-color: rgba(73, 34, 34, 0.8);
            color: #ff9999;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid #b55252;
        }
        .tab-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            background-color: rgba(30, 24, 18, 0.7);
            color: #a89c8a;
            border: 1px solid #5a4526;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            transition: all 0.3s ease;
        }
        .tab.active {
            background-color: #3d2e16;
            color: #c0a062;
        }
        .tab:first-child {
            border-radius: 5px 0 0 5px;
        }
        .tab:last-child {
            border-radius: 0 5px 5px 0;
        }
        .form-container {
            display: none;
        }
        .form-container.active {
            display: block;
        }
        
        /* Media query para dispositivos mÃ³viles */
        @media (max-width: 768px) {
            body {
                background-position: 30% center;
                padding: 10px;
            }
            .welcome-title {
                font-size: 22px;
            }
            .welcome-subtitle {
                font-size: 18px;
            }
            .arkham-logo {
                max-width: 150px;
                margin: 15px auto;
            }
            .content-wrapper {
                padding: 10px;
                margin-bottom: 10px;
            }
        }
    </style>
    <script>
        function showForm(formId) {
            // Ocultar todos los formularios
            document.querySelectorAll('.form-container').forEach(function(form) {
                form.classList.remove('active');
            });
            
            // Desactivar todas las pestaÃ±as
            document.querySelectorAll('.tab').forEach(function(tab) {
                tab.classList.remove('active');
            });
            
            // Mostrar el formulario seleccionado
            document.getElementById(formId).classList.add('active');
            
            // Activar la pestaÃ±a seleccionada
            document.querySelector('[onclick="showForm(\'' + formId + '\')"]').classList.add('active');
        }
    </script>
</head>
<body>
    <div class="content-wrapper">
       
        <div class="welcome-title">Bienvenido al 2Âº aniversario de Ignota Alicante</div>
        <div class="welcome-subtitle">Accede a tu mesa asignada</div>
    </div>
    
    <div class="content-wrapper">
        {% if get_flashed_messages(category_filter=["error"]) %}
            <div class="error-message">
                {{ get_flashed_messages(category_filter=["error"])[0] }}
            </div>
        {% endif %}
        
        <div class="tab-container">
            <div class="tab active" onclick="showForm('user-form')">Mesa</div>
            <div class="tab" onclick="showForm('admin-form')">Administrador</div>
        </div>
        
        <div id="user-form" class="form-container active">
            <form method="post" class="login-form">
                <div class="form-group">
                    <input type="text" name="access_code" class="input-field" placeholder="CÃ³digo de la Mesa (Ej: mesa01)" required>
                </div>
                <button type="submit" class="submit-button">Acceder</button>
            </form>
        </div>
        
        <div id="admin-form" class="form-container">
            <form method="post" class="login-form">
                <div class="form-group">
                    <input type="text" name="admin_username" class="input-field" placeholder="Usuario Admin" required>
                </div>
                <div class="form-group">
                    <input type="password" name="admin_password" class="input-field" placeholder="ContraseÃ±a" required>
                </div>
                <button type="submit" class="submit-button">Acceder como Admin</button>
            </form>
        </div>
    </div>
</body>
</html>


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\views\templates\print_qr.html
--------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CÃ³digos QR para Mesas - Arkham Horror</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=EB+Garamond&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'EB Garamond', serif;
            margin: 0;
            padding: 15px;
            background-color: white;
            color: #333;
        }
        
        .header {
            font-family: 'Cinzel', serif;
            padding: 15px;
            background-color: #3d2e16;
            color: #c0a062;
            margin-bottom: 20px;
            text-align: center;
            border-radius: 5px;
        }
        
        .admin-actions {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .btn {
            padding: 10px 15px;
            background-color: #3d2e16;
            color: #c0a062;
            border: 1px solid #5a4526;
            border-radius: 5px;
            text-decoration: none;
            margin: 0 5px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            display: inline-block;
        }
        
        .btn:hover {
            background-color: #5a4526;
        }
        
        .qr-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .qr-card {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            page-break-inside: avoid;
        }
        
        .qr-image {
            max-width: 100%;
            margin-bottom: 10px;
        }
        
        .qr-details {
            margin-top: 10px;
            font-size: 14px;
        }
        
        .qr-title {
            font-family: 'Cinzel', serif;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .print-instruction {
            text-align: center;
            margin: 20px 0;
            color: #555;
            font-style: italic;
        }
        
        @media print {
            .header, .admin-actions, .print-instruction {
                display: none;
            }
            
            body {
                padding: 0;
                margin: 0;
            }
            
            .qr-grid {
                gap: 10px;
            }
            
            .qr-card {
                box-shadow: none;
                border: 1px solid #eee;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CÃ³digos QR para Mesas</h1>
        <p>2Âº Aniversario de Ignota Alicante</p>
    </div>
    
    <div class="admin-actions">
        <a href="{{ url_for('admin.panel') }}" class="btn">â† Volver al Panel</a>
        <button onclick="window.print()" class="btn">Imprimir CÃ³digos QR</button>
    </div>
    
    <div class="print-instruction">
        <p>Estos cÃ³digos QR permitirÃ¡n a los jugadores acceder directamente a su mesa asignada escaneÃ¡ndolos con su telÃ©fono.</p>
        <p>Para imprimir todos los cÃ³digos, haz clic en el botÃ³n "Imprimir CÃ³digos QR" o utiliza Ctrl+P (Cmd+P en Mac).</p>
    </div>
    
    <div class="qr-grid">
        {% for mesa_code, qr_data in mesa_qr_data.items() %}
            <div class="qr-card">
                <div class="qr-title">{{ qr_data.mesa_name }}</div>
                <img src="data:image/png;base64,{{ qr_data.img_base64 }}" alt="QR {{ qr_data.mesa_name }}" class="qr-image">
                <div class="qr-details">
                    <p>{{ qr_data.group_name }} - {{ qr_data.era_name }}</p>
                    <p>CÃ³digo: {{ mesa_code }}</p>
                </div>
            </div>
        {% endfor %}
    </div>
</body>
</html>


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\views\templates\room.html
--------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ room.name }} - Arkham Horror</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=EB+Garamond&display=swap" rel="stylesheet">
    <!-- Agregar Socket.IO cliente -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        body {
            font-family: 'EB Garamond', serif;
            margin: 0;
            padding: 15px;
            background-color: #0a0a0a;
            background-image: url('https://i.postimg.cc/8PGqXKYC/borja-pindado-ah-walkingthroughtime-borjapindado-1.jpg');
            background-position: center center;
            background-repeat: no-repeat;
            background-size: cover;
            background-attachment: fixed;
            color: #d4c8a8;
            min-height: 100vh;
        }
        .content-wrapper {
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        .era-nav {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin: 20px 0;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }
        .era-link {
            font-family: 'Cinzel', serif;
            text-decoration: none;
            color: #c0a062;
            padding: 15px;
            border-radius: 5px;
            font-weight: bold;
            background-color: rgba(20, 20, 20, 0.8);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            text-align: center;
            border: 1px solid #3a3223;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .era-link:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7);
            background-color: rgba(30, 24, 18, 0.9);
        }
        .era-link.pasado:before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://i.ibb.co/KxTvNyS/past-symbol.png');
            background-size: 40px;
            background-repeat: no-repeat;
            background-position: 95% center;
            opacity: 0.3;
        }
        .era-link.presente:before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://i.ibb.co/0jZ3FBM/elder-sign.png');
            background-size: 40px;
            background-repeat: no-repeat;
            background-position: 95% center;
            opacity: 0.3;
        }
        .era-link.futuro:before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://i.ibb.co/Kzmh91y/future-symbol.png');
            background-size: 40px;
            background-repeat: no-repeat;
            background-position: 95% center;
            opacity: 0.3;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            color: #a89c8a;
            text-decoration: none;
            font-size: 16px;
            transition: color 0.3s ease;
        }
        .back-link:hover {
            color: #c0a062;
        }
        h1 {
            font-family: 'Cinzel', serif;
            color: #c0a062;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }
        .subtitle {
            color: #a89c8a;
            text-align: center;
            margin-bottom: 30px;
            font-size: 18px;
            font-style: italic;
        }
        .admin-badge {
            display: inline-block;
            background-color: #492222;
            color: #ff9999;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            margin: 0 auto 15px auto;
            border: 1px solid #6d3636;
            text-align: center;
            width: 150px;
        }
        
        /* Media query para dispositivos mÃ³viles */
        @media (max-width: 768px) {
            body {
                background-position: 30% center;
                padding: 10px;
            }
            h1 {
                font-size: 22px;
            }
            .subtitle {
                font-size: 16px;
                margin-bottom: 20px;
            }
            .era-link {
                padding: 12px;
            }
            .content-wrapper {
                padding: 10px;
                margin-bottom: 10px;
            }
            .era-link:before {
                background-size: 30px;
            }
        }
    </style>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Inicializar Socket.IO
            const socket = io();
            
            // Para cualquier funcionalidad futura en la pÃ¡gina de sala
            const currentRoom = {{ room.id }};
            
            // Unirse a la sala al cargar la pÃ¡gina
            socket.on('connect', function() {
                console.log('Connected to Socket.IO');
            });
        });
    </script>
</head>
<body>
    <div class="content-wrapper">
        {% if is_admin %}
            <div class="admin-badge">MODO ADMINISTRADOR</div>
        {% endif %}
        
        {% if is_admin %}
            <a href="{{ url_for('admin.panel') }}" class="back-link">â† Volver al panel de admin</a>
        {% else %}
            <a href="{{ url_for('auth.logout') }}" class="back-link">â† Cerrar sesiÃ³n</a>
        {% endif %}
        
        <h1>{{ room.name }}</h1>
        <div class="subtitle">Elige tu era</div>
    </div>
    
    <div class="content-wrapper">
        <div class="era-nav">
            <a href="{{ url_for('game.era', room_id=room.id, era='pasado') }}" class="era-link pasado">Pasado</a>
            <a href="{{ url_for('game.era', room_id=room.id, era='presente') }}" class="era-link presente">Presente</a>
            <a href="{{ url_for('game.era', room_id=room.id, era='futuro') }}" class="era-link futuro">Futuro</a>
        </div>
    </div>
</body>
</html>


Archivo: C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\__pycache__\__init__.cpython-313.pyc
--------------------------------------------------
ó

    ¡ùgº  ã                   ó:   • S SK Jr  S SKJr  SSKJr  \" SS9rS rg)	é    )ÚFlask)ÚSocketIOé   )Ú
get_configÚ*)Úcors_allowed_originsc                  ó   • [        [        SSS9n [        5       nU R                  R	                  U5        [
        R
                  U 5        SSKJn  SSK	J
n  SSKJn  U R                  U5        U R                  USS	9  U R                  U5        U $ )
u5   FunciÃ³n para crear y configurar la aplicaciÃ³n Flaskzviews/templatesÚstatic)Útemplate_folderÚ
static_folderr   )Úauth_bp)Úadmin_bp)Úroom_bpz/admin)Ú
url_prefix)r   Ú__name__r   ÚconfigÚfrom_objectÚsocketioÚinit_appÚapp.controllers.auth_controllerr
   Ú app.controllers.admin_controllerr   Úapp.controllers.room_controllerr   Úregister_blueprint)ÚappÚ
app_configr
   r   r   s        Ú9C:\Users\GGTECH\Documents\PERSONAL\ARKHAM\app\__init__.pyÚ
create_appr      s~   € ä
”Ø 1Ø&ñ(€Cô
 “€JØ‡JJ×Ñ˜:Ô&ô 
×ÑcÔõ 8Ý9Ý7à×Ñ˜7Ô#Ø×Ñ˜8°ÐÑ9Ø×Ñ˜7Ô#à€Jó    N)Úflaskr   Úflask_socketior   r   r   r   r   © r   r   Ú<module>r"      s   ðÝ Ý #Ý ñ ¨Ñ-€ór   


